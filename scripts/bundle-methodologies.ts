#!/usr/bin/env node

/**
 * Bundle methodology files into a single JSON file for browser compatibility
 */

import { existsSync } from 'node:fs';
import fs from 'node:fs/promises';
import path from 'node:path';
import yaml from 'yaml';

const TIDAS_TOOLS_DIR = path.join(
  __dirname,
  '../tidas-tools/src/tidas_tools/tidas/'
);

const METHODOLOGY_DIR = path.join(TIDAS_TOOLS_DIR, 'methodologies');
const OUTPUT_DIR = path.join(__dirname, '../src/data');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'bundled-methodologies.json');

/**
 * Mapping of methodology files to their paths (potential files that might exist)
 */
const methodologyFilesMapping: Record<string, string> = {
  contacts: path.join(METHODOLOGY_DIR, 'tidas_contacts.yaml'),
  contacts_category: path.join(METHODOLOGY_DIR, 'tidas_contacts_category.yaml'),
  data_types: path.join(METHODOLOGY_DIR, 'tidas_data_types.yaml'),
  flowproperties_category: path.join(
    METHODOLOGY_DIR,
    'tidas_flowproperties_category.yaml'
  ),
  flowproperties: path.join(METHODOLOGY_DIR, 'tidas_flowproperties.yaml'),
  flows_elementary_category: path.join(
    METHODOLOGY_DIR,
    'tidas_flows_elementary_category.yaml'
  ),
  flows: path.join(METHODOLOGY_DIR, 'tidas_flows.yaml'),
  lifecyclemodels: path.join(METHODOLOGY_DIR, 'tidas_lifecyclemodels.yaml'),
  lciamethods: path.join(METHODOLOGY_DIR, 'tidas_lciamethods.yaml'),
  lciamethods_category: path.join(
    METHODOLOGY_DIR,
    'tidas_lciamethods_category.yaml'
  ),
  locations_category: path.join(
    METHODOLOGY_DIR,
    'tidas_locations_category.yaml'
  ),
  processes: path.join(METHODOLOGY_DIR, 'tidas_processes.yaml'),
  processes_category: path.join(
    METHODOLOGY_DIR,
    'tidas_processes_category.yaml'
  ),
  sources: path.join(METHODOLOGY_DIR, 'tidas_sources.yaml'),
  sources_category: path.join(METHODOLOGY_DIR, 'tidas_sources_category.yaml'),
  unitgroups: path.join(METHODOLOGY_DIR, 'tidas_unitgroups.yaml'),
  unitgroups_category: path.join(
    METHODOLOGY_DIR,
    'tidas_unitgroups_category.yaml'
  ),
};

/**
 * Read a methodology file and return the data as a JSON object.
 */
async function readMethodologyFile(filePath: string) {
  const file = await fs.readFile(filePath, 'utf8');
  return yaml.parse(file);
}

async function main() {
  console.log('üöÄ Starting methodology bundling process...');

  // Ensure output directory exists
  if (!existsSync(OUTPUT_DIR)) {
    await fs.mkdir(OUTPUT_DIR, { recursive: true });
    console.log(`‚úì Created output directory: ${OUTPUT_DIR}`);
  }

  // Bundle all methodology files
  const bundledData: Record<string, any> = {};
  let processedCount = 0;
  let skippedCount = 0;

  for (const [key, filePath] of Object.entries(methodologyFilesMapping)) {
    try {
      if (existsSync(filePath)) {
        console.log(`üìñ Reading ${key} from ${filePath}`);
        const data = await readMethodologyFile(filePath);
        bundledData[key] = data;
        processedCount++;
        console.log(`‚úì Successfully bundled ${key}`);
      } else {
        console.log(`‚ö†Ô∏è  Skipping ${key} (file not found: ${filePath})`);
        skippedCount++;
      }
    } catch (error) {
      console.error(`‚ùå Error processing ${key}:`, error);
      skippedCount++;
    }
  }

  // Add metadata
  const bundleMetadata = {
    bundled_at: new Date().toISOString(),
    total_files: Object.keys(methodologyFilesMapping).length,
    processed_files: processedCount,
    skipped_files: skippedCount,
    file_list: Object.keys(bundledData),
  };

  const finalBundle = {
    _metadata: bundleMetadata,
    methodologies: bundledData,
  };

  // Write the bundled data
  await fs.writeFile(
    OUTPUT_FILE,
    JSON.stringify(finalBundle, null, 2),
    'utf8'
  );

  console.log(`\nüéâ Bundling completed!`);
  console.log(`üì¶ Output file: ${OUTPUT_FILE}`);
  console.log(`üìä Processed: ${processedCount} files`);
  console.log(`‚è≠Ô∏è  Skipped: ${skippedCount} files`);
  console.log(`üìã Bundled methodologies: ${Object.keys(bundledData).join(', ')}`);

  // Generate TypeScript declaration file
  await generateTypeDeclaration(bundledData);
}

/**
 * Generate TypeScript declaration file for the bundled data
 */
async function generateTypeDeclaration(bundledData: Record<string, any>) {
  const declarationPath = path.join(OUTPUT_DIR, 'bundled-methodologies.d.ts');
  
  const lines: string[] = [
    '/**',
    ' * TypeScript declarations for bundled methodology data',
    ' * Auto-generated by bundle-methodologies.ts',
    ' */',
    '',
    'export interface BundleMetadata {',
    '  bundled_at: string;',
    '  total_files: number;',
    '  processed_files: number;',
    '  skipped_files: number;',
    '  file_list: string[];',
    '}',
    '',
    'export interface BundledMethodologies {',
    '  _metadata: BundleMetadata;',
    '  methodologies: {',
  ];

  // Add type for each methodology
  for (const key of Object.keys(bundledData)) {
    lines.push(`    ${key}?: any;`);
  }

  lines.push(
    '  };',
    '}',
    '',
    'declare const bundledMethodologies: BundledMethodologies;',
    'export default bundledMethodologies;'
  );

  await fs.writeFile(declarationPath, lines.join('\n'), 'utf8');
  console.log(`‚úì Generated TypeScript declarations: ${declarationPath}`);
}

if (require.main === module) {
  main().catch(console.error);
}