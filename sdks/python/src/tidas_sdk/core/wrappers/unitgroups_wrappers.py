"""
Auto-generated typed wrappers for unitgroups entity.

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated from JSON schemas.
To regenerate, run: python scripts/generate_types_v2.py
"""

from typing import Optional

from tidas_sdk.core.typed_access import BaseWrapper, MultiLangText



class UnitsWrapper(BaseWrapper):
    """Auto-generated wrapper for UnitsWrapper."""

    __slots__ = ()

    @property
    def unit(self) -> Optional[str]:
        """Access unit field"""
        return self._data.get("unit")

    @unit.setter
    def unit(self, value: Optional[str]) -> None:
        """Set unit."""
        if value is None:
            self._data.pop("unit", None)
        else:
            self._data["unit"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class PublicationAndOwnershipWrapper(BaseWrapper):
    """Auto-generated wrapper for PublicationAndOwnershipWrapper."""

    __slots__ = ()

    @property
    def data_set_version(self) -> str:
        """Version number of data set. First two digits refer to major updates, the second two digits to minor revisions and error corrections etc. The third three digits are intended for automatic and internal counting of versions during data set development. Together with the data set's UUID, the "Data set version" uniquely identifies each data set."""
        return self._data.get("common:dataSetVersion")

    @data_set_version.setter
    def data_set_version(self, value: str) -> None:
        """Set common:dataSetVersion."""
        self._data["common:dataSetVersion"] = value

    @property
    def reference_to_preceding_data_set_version(self) -> Optional[str]:
        """Last preceding data set, which was replaced by this version. Either a URI of that data set (i.e. an internet address) or its UUID plus version number is given (or both)."""
        return self._data.get("common:referenceToPrecedingDataSetVersion")

    @reference_to_preceding_data_set_version.setter
    def reference_to_preceding_data_set_version(self, value: Optional[str]) -> None:
        """Set common:referenceToPrecedingDataSetVersion."""
        if value is None:
            self._data.pop("common:referenceToPrecedingDataSetVersion", None)
        else:
            self._data["common:referenceToPrecedingDataSetVersion"] = value

    @property
    def permanent_data_set_uri(self) -> Optional[str]:
        """URI (i.e. an internet address) of the original of this data set. [Note: This equally globally unique identifier supports users and software tools to identify and retrieve the original version of a data set via the internet or to check for available updates. The URI must not represent an existing WWW address, but it should be unique and point to the data access point, e.g. by combining the data owner's www path with the data set's UUID, e.g. http://www.mycompany.com/lca/processes/50f12420-8855-12db-b606-0900210c9a66.]"""
        return self._data.get("common:permanentDataSetURI")

    @permanent_data_set_uri.setter
    def permanent_data_set_uri(self, value: Optional[str]) -> None:
        """Set common:permanentDataSetURI."""
        if value is None:
            self._data.pop("common:permanentDataSetURI", None)
        else:
            self._data["common:permanentDataSetURI"] = value

    @property
    def reference_to_ownership_of_data_set(self) -> str:
        """"Contact data set" of the person or entity who owns this data set. (Note: this is not necessarily the publisher of the data set.)"""
        return self._data.get("common:referenceToOwnershipOfDataSet")

    @reference_to_ownership_of_data_set.setter
    def reference_to_ownership_of_data_set(self, value: str) -> None:
        """Set common:referenceToOwnershipOfDataSet."""
        self._data["common:referenceToOwnershipOfDataSet"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataEntryByWrapper(BaseWrapper):
    """Auto-generated wrapper for DataEntryByWrapper."""

    __slots__ = ()

    @property
    def time_stamp(self) -> str:
        """Date and time stamp of data set generation, typically an automated entry ("last saved")."""
        return self._data.get("common:timeStamp")

    @time_stamp.setter
    def time_stamp(self, value: str) -> None:
        """Set common:timeStamp."""
        self._data["common:timeStamp"] = value

    @property
    def reference_to_data_set_format(self) -> str:
        """"Source data set" of the used version of the ILCD format. If additional data format fields have been integrated into the data set file, using the "namespace" option, the used format namespace(s) are to be given. This is the case if the data sets carries additional information as specified by other, particular LCA formats, e.g. of other database networks or LCA softwares."""
        return self._data.get("common:referenceToDataSetFormat")

    @reference_to_data_set_format.setter
    def reference_to_data_set_format(self, value: str) -> None:
        """Set common:referenceToDataSetFormat."""
        self._data["common:referenceToDataSetFormat"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class AdministrativeInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for AdministrativeInformationWrapper."""

    __slots__ = ()

    @property
    def data_entry_by(self) -> DataEntryByWrapper:
        """Access dataEntryBy nested object"""
        self._ensure_field("dataEntryBy")
        return DataEntryByWrapper(self._entity, self._data["dataEntryBy"])

    @property
    def publication_and_ownership(self) -> PublicationAndOwnershipWrapper:
        """Access publicationAndOwnership nested object"""
        self._ensure_field("publicationAndOwnership")
        return PublicationAndOwnershipWrapper(self._entity, self._data["publicationAndOwnership"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ComplianceWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplianceWrapper."""

    __slots__ = ()

    @property
    def reference_to_compliance_system(self) -> str:
        """Access common:referenceToComplianceSystem field"""
        return self._data.get("common:referenceToComplianceSystem")

    @reference_to_compliance_system.setter
    def reference_to_compliance_system(self, value: str) -> None:
        """Set common:referenceToComplianceSystem."""
        self._data["common:referenceToComplianceSystem"] = value

    @property
    def approval_of_overall_compliance(self) -> str:
        """Access common:approvalOfOverallCompliance field"""
        return self._data.get("common:approvalOfOverallCompliance")

    @approval_of_overall_compliance.setter
    def approval_of_overall_compliance(self, value: str) -> None:
        """Set common:approvalOfOverallCompliance."""
        self._data["common:approvalOfOverallCompliance"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ComplianceDeclarationsWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplianceDeclarationsWrapper."""

    __slots__ = ()

    @property
    def compliance(self) -> ComplianceWrapper:
        """Access compliance nested object"""
        self._ensure_field("compliance")
        return ComplianceWrapper(self._entity, self._data["compliance"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ModellingAndValidationWrapper(BaseWrapper):
    """Auto-generated wrapper for ModellingAndValidationWrapper."""

    __slots__ = ()

    @property
    def compliance_declarations(self) -> ComplianceDeclarationsWrapper:
        """Access complianceDeclarations nested object"""
        self._ensure_field("complianceDeclarations")
        return ComplianceDeclarationsWrapper(self._entity, self._data["complianceDeclarations"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class QuantitativeReferenceWrapper(BaseWrapper):
    """Auto-generated wrapper for QuantitativeReferenceWrapper."""

    __slots__ = ()

    @property
    def reference_to_reference_unit(self) -> str:
        """Access referenceToReferenceUnit field"""
        return self._data.get("referenceToReferenceUnit")

    @reference_to_reference_unit.setter
    def reference_to_reference_unit(self, value: str) -> None:
        """Set referenceToReferenceUnit."""
        self._data["referenceToReferenceUnit"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassWrapper."""

    __slots__ = ()

    @property
    def level(self) -> str:
        """If more than one class is specified in a hierachical classification system, the hierarchy level (1,2,...) could be specified with this attribute of class."""
        return self._data.get("@level")

    @level.setter
    def level(self, value: str) -> None:
        """Set @level."""
        self._data["@level"] = value

    @property
    def class_id(self) -> str:
        """Unique identifier for the class. [Notes: If such identifiers are also defined in the referenced category file, they should be identical. Identifiers can be UUID's, but also other forms are allowed.]"""
        return self._data.get("@classId")

    @class_id.setter
    def class_id(self, value: str) -> None:
        """Set @classId."""
        self._data["@classId"] = value

    @property
    def text(self) -> str:
        """Access #text field"""
        return self._data.get("#text")

    @text.setter
    def text(self, value: str) -> None:
        """Set #text."""
        self._data["#text"] = value


class ClassificationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationWrapper."""

    __slots__ = ()

    @property
    def class_(self) -> ClassWrapper:
        """Access common:class nested object"""
        self._ensure_field("common:class")
        return ClassWrapper(self._entity, self._data["common:class"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassificationInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationInformationWrapper."""

    __slots__ = ()

    @property
    def classification(self) -> ClassificationWrapper:
        """Optional statistical or other classification of the data set. Typically also used for structuring LCA databases."""
        self._ensure_field("common:classification")
        return ClassificationWrapper(self._entity, self._data["common:classification"])


class DataSetInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for DataSetInformationWrapper."""

    __slots__ = ()

    @property
    def uuid(self) -> str:
        """Automatically generated Universally Unique Identifier of this data set. Together with the "Data set version", the UUID uniquely identifies each data set."""
        return self._data.get("common:UUID")

    @uuid.setter
    def uuid(self, value: str) -> None:
        """Set common:UUID."""
        self._data["common:UUID"] = value

    @property
    def name(self) -> MultiLangText:
        """Name of the unit group, typically indicating for which flow property or group of flow properties it is used. The individual units are named in the "Units" section of the "Unit group data set"."""
        return self._get_multi_lang("common:name")

    @property
    def classification_information(self) -> ClassificationInformationWrapper:
        """Hierachical classification of the Unit groups; foreseen to be used to structure the Unit group content of the database. (Note: This entry is NOT required for the identification of the Unit group data set. It should nevertheless be avoided to use identical names for Unit groups in the same class."""
        self._ensure_field("classificationInformation")
        return ClassificationInformationWrapper(self._entity, self._data["classificationInformation"])

    @property
    def general_comment(self) -> MultiLangText:
        """Free text for general information about the data set. E.g. coverage of different unit systems, information sources used, etc."""
        return self._get_multi_lang("common:generalComment")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class UnitGroupInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for UnitGroupInformationWrapper."""

    __slots__ = ()

    @property
    def data_set_information(self) -> DataSetInformationWrapper:
        """Access dataSetInformation nested object"""
        self._ensure_field("dataSetInformation")
        return DataSetInformationWrapper(self._entity, self._data["dataSetInformation"])

    @property
    def quantitative_reference(self) -> QuantitativeReferenceWrapper:
        """Access quantitativeReference nested object"""
        self._ensure_field("quantitativeReference")
        return QuantitativeReferenceWrapper(self._entity, self._data["quantitativeReference"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class UnitgroupsDataSetWrapper(BaseWrapper):
    """Auto-generated wrapper for UnitgroupsDataSetWrapper."""

    __slots__ = ()

    @property
    def version(self) -> str:
        """Access @version field"""
        return self._data.get("@version")

    @version.setter
    def version(self, value: str) -> None:
        """Set @version."""
        self._data["@version"] = value

    @property
    def schema_location(self) -> str:
        """Access @xsi:schemaLocation field"""
        return self._data.get("@xsi:schemaLocation")

    @schema_location.setter
    def schema_location(self, value: str) -> None:
        """Set @xsi:schemaLocation."""
        self._data["@xsi:schemaLocation"] = value

    @property
    def unit_group_information(self) -> UnitGroupInformationWrapper:
        """Access unitGroupInformation nested object"""
        self._ensure_field("unitGroupInformation")
        return UnitGroupInformationWrapper(self._entity, self._data["unitGroupInformation"])

    @property
    def modelling_and_validation(self) -> ModellingAndValidationWrapper:
        """Access modellingAndValidation nested object"""
        self._ensure_field("modellingAndValidation")
        return ModellingAndValidationWrapper(self._entity, self._data["modellingAndValidation"])

    @property
    def administrative_information(self) -> AdministrativeInformationWrapper:
        """Access administrativeInformation nested object"""
        self._ensure_field("administrativeInformation")
        return AdministrativeInformationWrapper(self._entity, self._data["administrativeInformation"])

    @property
    def units(self) -> UnitsWrapper:
        """Access units nested object"""
        self._ensure_field("units")
        return UnitsWrapper(self._entity, self._data["units"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value
