"""
Auto-generated typed wrappers for processes entity.

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated from JSON schemas.
To regenerate, run: python scripts/generate_types_v2.py
"""

from typing import Optional

from tidas_sdk.core.typed_access import BaseWrapper, MultiLangText



class LciaResultWrapper(BaseWrapper):
    """Auto-generated wrapper for LciaResultWrapper."""

    __slots__ = ()

    @property
    def reference_to_lcia_method_data_set(self) -> Optional[str]:
        """"LCIA method data set" applied to calculate the LCIA results."""
        return self._data.get("referenceToLCIAMethodDataSet")

    @reference_to_lcia_method_data_set.setter
    def reference_to_lcia_method_data_set(self, value: Optional[str]) -> None:
        """Set referenceToLCIAMethodDataSet."""
        if value is None:
            self._data.pop("referenceToLCIAMethodDataSet", None)
        else:
            self._data["referenceToLCIAMethodDataSet"] = value

    @property
    def mean_amount(self) -> str:
        """Mean amount of the Input or Output. Only significant digits of the amount should be stated."""
        return self._data.get("meanAmount")

    @mean_amount.setter
    def mean_amount(self, value: str) -> None:
        """Set meanAmount."""
        self._data["meanAmount"] = value

    @property
    def uncertainty_distribution_type(self) -> Optional[str]:
        """Access uncertaintyDistributionType field"""
        return self._data.get("uncertaintyDistributionType")

    @uncertainty_distribution_type.setter
    def uncertainty_distribution_type(self, value: Optional[str]) -> None:
        """Set uncertaintyDistributionType."""
        if value is None:
            self._data.pop("uncertaintyDistributionType", None)
        else:
            self._data["uncertaintyDistributionType"] = value

    @property
    def relative_standard_deviation95_in(self) -> Optional[str]:
        """The resulting overall uncertainty of the calculated variable value considering uncertainty of measurements, modelling, appropriateness etc. [Notes: For log-normal distribution the square of the geometric standard deviation (SDg^2) is stated. Mean value times SDg^2 equals the 97.5% value (= Maximum value), Mean value divided by SDg^2 equals the 2.5% value (= Minimum value). For normal distribution the doubled standard deviation value (2*SD) is entered. Mean value plus 2*SD equals 97.5% value (= Maximum value), Mean value minus 2*SD equals 2.5% value (= Minimum value). This data field remains empty when uniform or triangular uncertainty distribution is applied.]"""
        return self._data.get("relativeStandardDeviation95In")

    @relative_standard_deviation95_in.setter
    def relative_standard_deviation95_in(self, value: Optional[str]) -> None:
        """Set relativeStandardDeviation95In."""
        if value is None:
            self._data.pop("relativeStandardDeviation95In", None)
        else:
            self._data["relativeStandardDeviation95In"] = value

    @property
    def general_comment(self) -> MultiLangText:
        """General comment on this specific Input or Output, e.g. commenting on the data sources used and their specific representatuveness etc., on the status of "finalisation" of an entry as workflow information, etc."""
        return self._get_multi_lang("generalComment")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class LciaResultsWrapper(BaseWrapper):
    """Auto-generated wrapper for LciaResultsWrapper."""

    __slots__ = ()

    @property
    def lcia_result(self) -> LciaResultWrapper:
        """Access LCIAResult nested object"""
        self._ensure_field("LCIAResult")
        return LciaResultWrapper(self._entity, self._data["LCIAResult"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ExchangesWrapper(BaseWrapper):
    """Auto-generated wrapper for ExchangesWrapper."""

    __slots__ = ()

    @property
    def exchange(self) -> str:
        """Access exchange field"""
        return self._data.get("exchange")

    @exchange.setter
    def exchange(self, value: str) -> None:
        """Set exchange."""
        self._data["exchange"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class PublicationAndOwnershipWrapper(BaseWrapper):
    """Auto-generated wrapper for PublicationAndOwnershipWrapper."""

    __slots__ = ()

    @property
    def date_of_last_revision(self) -> Optional[str]:
        """Date when the data set was revised for the last time, typically manually set."""
        return self._data.get("common:dateOfLastRevision")

    @date_of_last_revision.setter
    def date_of_last_revision(self, value: Optional[str]) -> None:
        """Set common:dateOfLastRevision."""
        if value is None:
            self._data.pop("common:dateOfLastRevision", None)
        else:
            self._data["common:dateOfLastRevision"] = value

    @property
    def data_set_version(self) -> str:
        """Version number of data set. First two digits refer to major updates, the second two digits to minor revisions and error corrections etc. The third three digits are intended for automatic and internal counting of versions during data set development. Together with the data set's UUID, the "Data set version" uniquely identifies each data set."""
        return self._data.get("common:dataSetVersion")

    @data_set_version.setter
    def data_set_version(self, value: str) -> None:
        """Set common:dataSetVersion."""
        self._data["common:dataSetVersion"] = value

    @property
    def reference_to_preceding_data_set_version(self) -> Optional[str]:
        """Last preceding data set, which was replaced by this version. Either a URI of that data set (i.e. an internet address) or its UUID plus version number is given (or both)."""
        return self._data.get("common:referenceToPrecedingDataSetVersion")

    @reference_to_preceding_data_set_version.setter
    def reference_to_preceding_data_set_version(self, value: Optional[str]) -> None:
        """Set common:referenceToPrecedingDataSetVersion."""
        if value is None:
            self._data.pop("common:referenceToPrecedingDataSetVersion", None)
        else:
            self._data["common:referenceToPrecedingDataSetVersion"] = value

    @property
    def permanent_data_set_uri(self) -> str:
        """URI (i.e. an internet address) of the original of this data set. [Note: This equally globally unique identifier supports users and software tools to identify and retrieve the original version of a data set via the internet or to check for available updates. The URI must not represent an existing WWW address, but it should be unique and point to the data access point, e.g. by combining the data owner's www path with the data set's UUID, e.g. http://www.mycompany.com/lca/processes/50f12420-8855-12db-b606-0900210c9a66.]"""
        return self._data.get("common:permanentDataSetURI")

    @permanent_data_set_uri.setter
    def permanent_data_set_uri(self, value: str) -> None:
        """Set common:permanentDataSetURI."""
        self._data["common:permanentDataSetURI"] = value

    @property
    def workflow_and_publication_status(self) -> Optional[str]:
        """Workflow or publication status of data set. Details e.g. of foreseen publication dates should be provided on request by the "Data set owner"."""
        return self._data.get("common:workflowAndPublicationStatus")

    @workflow_and_publication_status.setter
    def workflow_and_publication_status(self, value: Optional[str]) -> None:
        """Set common:workflowAndPublicationStatus."""
        if value is None:
            self._data.pop("common:workflowAndPublicationStatus", None)
        else:
            self._data["common:workflowAndPublicationStatus"] = value

    @property
    def reference_to_unchanged_republication(self) -> Optional[str]:
        """"Source data set" of the publication, in which this data set was published for the first time. [Note: This refers to exactly this data set as it is, without any format conversion, adjustments, flow name mapping, etc. In case this data set was modified/converted, the original source is documented in "Converted original data set from:" in section "Data entry by".]"""
        return self._data.get("common:referenceToUnchangedRepublication")

    @reference_to_unchanged_republication.setter
    def reference_to_unchanged_republication(self, value: Optional[str]) -> None:
        """Set common:referenceToUnchangedRepublication."""
        if value is None:
            self._data.pop("common:referenceToUnchangedRepublication", None)
        else:
            self._data["common:referenceToUnchangedRepublication"] = value

    @property
    def reference_to_registration_authority(self) -> Optional[str]:
        """"Contact data set" of the authority that has registered this data set."""
        return self._data.get("common:referenceToRegistrationAuthority")

    @reference_to_registration_authority.setter
    def reference_to_registration_authority(self, value: Optional[str]) -> None:
        """Set common:referenceToRegistrationAuthority."""
        if value is None:
            self._data.pop("common:referenceToRegistrationAuthority", None)
        else:
            self._data["common:referenceToRegistrationAuthority"] = value

    @property
    def registration_number(self) -> Optional[str]:
        """A unique identifying number for this data set issued by the registration authority."""
        return self._data.get("common:registrationNumber")

    @registration_number.setter
    def registration_number(self, value: Optional[str]) -> None:
        """Set common:registrationNumber."""
        if value is None:
            self._data.pop("common:registrationNumber", None)
        else:
            self._data["common:registrationNumber"] = value

    @property
    def reference_to_ownership_of_data_set(self) -> str:
        """"Contact data set" of the person or entity who owns this data set. (Note: this is not necessarily the publisher of the data set.)"""
        return self._data.get("common:referenceToOwnershipOfDataSet")

    @reference_to_ownership_of_data_set.setter
    def reference_to_ownership_of_data_set(self, value: str) -> None:
        """Set common:referenceToOwnershipOfDataSet."""
        self._data["common:referenceToOwnershipOfDataSet"] = value

    @property
    def copyright(self) -> str:
        """Indicates whether or not a copyright on the data set exists. Decided upon by the "Owner of data set". [Note: See also field "Access and use restrictions".]"""
        return self._data.get("common:copyright")

    @copyright.setter
    def copyright(self, value: str) -> None:
        """Set common:copyright."""
        self._data["common:copyright"] = value

    @property
    def reference_to_entities_with_exclusive_access(self) -> Optional[str]:
        """"Contact data set" of those entities or persons (or groups of these), to which an exclusive access to this data set is granted. Mainly intended to be used in confidentiality management in projects. [Note: See also field "Access and use restrictions".]"""
        return self._data.get("common:referenceToEntitiesWithExclusiveAccess")

    @reference_to_entities_with_exclusive_access.setter
    def reference_to_entities_with_exclusive_access(self, value: Optional[str]) -> None:
        """Set common:referenceToEntitiesWithExclusiveAccess."""
        if value is None:
            self._data.pop("common:referenceToEntitiesWithExclusiveAccess", None)
        else:
            self._data["common:referenceToEntitiesWithExclusiveAccess"] = value

    @property
    def license_type(self) -> str:
        """Type of license that applies to the access and use of this data set."""
        return self._data.get("common:licenseType")

    @license_type.setter
    def license_type(self, value: str) -> None:
        """Set common:licenseType."""
        self._data["common:licenseType"] = value

    @property
    def access_restrictions(self) -> MultiLangText:
        """Access restrictions / use conditions for this data set as free text or referring to e.g. license conditions. In case of no restrictions "None" is entered."""
        return self._get_multi_lang("common:accessRestrictions")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataEntryByWrapper(BaseWrapper):
    """Auto-generated wrapper for DataEntryByWrapper."""

    __slots__ = ()

    @property
    def time_stamp(self) -> str:
        """Access common:timeStamp field"""
        return self._data.get("common:timeStamp")

    @time_stamp.setter
    def time_stamp(self, value: str) -> None:
        """Set common:timeStamp."""
        self._data["common:timeStamp"] = value

    @property
    def reference_to_data_set_format(self) -> str:
        """"Source data set" of the used version of the ILCD format. If additional data format fields have been integrated into the data set file, using the "namespace" option, the used format namespace(s) are to be given. This is the case if the data sets carries additional information as specified by other, particular LCA formats, e.g. of other database networks or LCA softwares."""
        return self._data.get("common:referenceToDataSetFormat")

    @reference_to_data_set_format.setter
    def reference_to_data_set_format(self, value: str) -> None:
        """Set common:referenceToDataSetFormat."""
        self._data["common:referenceToDataSetFormat"] = value

    @property
    def reference_to_converted_original_data_set_from(self) -> Optional[str]:
        """"Source data set" of the database or data set publication from which this data set has been obtained by conversion. This can cover e.g. conversion to a different format, applying a different nomenclature, mapping of flow names, conversion of units, etc. This may however not have changed or re-modeled the Inputs and Outputs, i.e. obtaining the same LCIA results. This entry is required for converted data sets stemming originally from other LCA databases (e.g. when re-publishing data from IISI, ILCD etc. databases). [Note: Identically re-published data sets are identied in the field "Unchanged re-publication of:" in the section "Publication and Ownership".]"""
        return self._data.get("common:referenceToConvertedOriginalDataSetFrom")

    @reference_to_converted_original_data_set_from.setter
    def reference_to_converted_original_data_set_from(self, value: Optional[str]) -> None:
        """Set common:referenceToConvertedOriginalDataSetFrom."""
        if value is None:
            self._data.pop("common:referenceToConvertedOriginalDataSetFrom", None)
        else:
            self._data["common:referenceToConvertedOriginalDataSetFrom"] = value

    @property
    def reference_to_person_or_entity_entering_the_data(self) -> str:
        """"Contact data set" of the responsible person or entity that has documented this data set, i.e. entered the data and the descriptive information."""
        return self._data.get("common:referenceToPersonOrEntityEnteringTheData")

    @reference_to_person_or_entity_entering_the_data.setter
    def reference_to_person_or_entity_entering_the_data(self, value: str) -> None:
        """Set common:referenceToPersonOrEntityEnteringTheData."""
        self._data["common:referenceToPersonOrEntityEnteringTheData"] = value

    @property
    def reference_to_data_set_use_approval(self) -> Optional[str]:
        """"Source data set": Names exclusively the producer or operator of the good, service or technology represented by this data set, which officially has approved this data set in all its parts. In case of nationally or internationally averaged data sets, this will be the respective business association. If no official approval has been given, the entry "No official approval by producer or operator" is to be entered and the reference will point to an empty "Contact data set". [Notes: The producer or operator may only be named here, if a written approval of this data set was given. A recognition of this data set by any other organisation then the producer/operator of the good, service, or process is not to be stated here, but as a "review" in the validation section.]"""
        return self._data.get("common:referenceToDataSetUseApproval")

    @reference_to_data_set_use_approval.setter
    def reference_to_data_set_use_approval(self, value: Optional[str]) -> None:
        """Set common:referenceToDataSetUseApproval."""
        if value is None:
            self._data.pop("common:referenceToDataSetUseApproval", None)
        else:
            self._data["common:referenceToDataSetUseApproval"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataGeneratorWrapper(BaseWrapper):
    """Auto-generated wrapper for DataGeneratorWrapper."""

    __slots__ = ()

    @property
    def reference_to_person_or_entity_generating_the_data_set(self) -> Optional[str]:
        """"Contact data set" of the person(s), working group(s), organisation(s) or database network, that generated the data set, i.e. being responsible for its correctness regarding methods, inventory, and documentation."""
        return self._data.get("common:referenceToPersonOrEntityGeneratingTheDataSet")

    @reference_to_person_or_entity_generating_the_data_set.setter
    def reference_to_person_or_entity_generating_the_data_set(self, value: Optional[str]) -> None:
        """Set common:referenceToPersonOrEntityGeneratingTheDataSet."""
        if value is None:
            self._data.pop("common:referenceToPersonOrEntityGeneratingTheDataSet", None)
        else:
            self._data["common:referenceToPersonOrEntityGeneratingTheDataSet"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class CommissionerAndGoalWrapper(BaseWrapper):
    """Auto-generated wrapper for CommissionerAndGoalWrapper."""

    __slots__ = ()

    @property
    def reference_to_commissioner(self) -> str:
        """"Contact data set" of the commissioner / financing party of the data collection / compilation and of the data set modelling. For groups of commissioners, each single organisation should be named. For data set updates and for direct use of data from formerly commissioned studies, also the original commissioner should be named."""
        return self._data.get("common:referenceToCommissioner")

    @reference_to_commissioner.setter
    def reference_to_commissioner(self, value: str) -> None:
        """Set common:referenceToCommissioner."""
        self._data["common:referenceToCommissioner"] = value

    @property
    def project(self) -> MultiLangText:
        """Extract of the information items linked to goal and scope of LCIA method modeling."""
        return self._get_multi_lang("common:project")

    @property
    def intended_applications(self) -> MultiLangText:
        """Documentation of the intended application(s) of data collection and data set modelling. This indicates / includes information on the level of detail, the specifidity, and the quality ambition in the effort."""
        return self._get_multi_lang("common:intendedApplications")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class AdministrativeInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for AdministrativeInformationWrapper."""

    __slots__ = ()

    @property
    def commissioner_and_goal(self) -> CommissionerAndGoalWrapper:
        """Basic information about goal and scope of the data set."""
        self._ensure_field("common:commissionerAndGoal")
        return CommissionerAndGoalWrapper(self._entity, self._data["common:commissionerAndGoal"])

    @property
    def data_generator(self) -> DataGeneratorWrapper:
        """Expert(s), that compiled and modelled the data set as well as internal administrative information linked to the data generation activity."""
        self._ensure_field("dataGenerator")
        return DataGeneratorWrapper(self._entity, self._data["dataGenerator"])

    @property
    def data_entry_by(self) -> DataEntryByWrapper:
        """Staff or entity, that documented the generated data set, entering the information into the database; plus administrative information linked to the data entry activity."""
        self._ensure_field("dataEntryBy")
        return DataEntryByWrapper(self._entity, self._data["dataEntryBy"])

    @property
    def publication_and_ownership(self) -> PublicationAndOwnershipWrapper:
        """Information related to publication and version management of the data set including copyright and access restrictions."""
        self._ensure_field("publicationAndOwnership")
        return PublicationAndOwnershipWrapper(self._entity, self._data["publicationAndOwnership"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ComplianceWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplianceWrapper."""

    __slots__ = ()

    @property
    def reference_to_compliance_system(self) -> str:
        """"Source data set" of the "Compliance system" that is declared to be met by the data set."""
        return self._data.get("common:referenceToComplianceSystem")

    @reference_to_compliance_system.setter
    def reference_to_compliance_system(self, value: str) -> None:
        """Set common:referenceToComplianceSystem."""
        self._data["common:referenceToComplianceSystem"] = value

    @property
    def approval_of_overall_compliance(self) -> str:
        """Official approval whether or not and in how far the data set meets all the requirements of the "Compliance system" refered to. This approval should be issued/confirmed by the owner of that compliance system, who is identified via the respective "Contact data set"."""
        return self._data.get("common:approvalOfOverallCompliance")

    @approval_of_overall_compliance.setter
    def approval_of_overall_compliance(self, value: str) -> None:
        """Set common:approvalOfOverallCompliance."""
        self._data["common:approvalOfOverallCompliance"] = value

    @property
    def nomenclature_compliance(self) -> str:
        """Nomenclature compliance of this data set with the respective requirements set by the "compliance system" refered to."""
        return self._data.get("common:nomenclatureCompliance")

    @nomenclature_compliance.setter
    def nomenclature_compliance(self, value: str) -> None:
        """Set common:nomenclatureCompliance."""
        self._data["common:nomenclatureCompliance"] = value

    @property
    def methodological_compliance(self) -> str:
        """Methodological compliance of this data set with the respective requirements set by the "compliance system" refered to."""
        return self._data.get("common:methodologicalCompliance")

    @methodological_compliance.setter
    def methodological_compliance(self, value: str) -> None:
        """Set common:methodologicalCompliance."""
        self._data["common:methodologicalCompliance"] = value

    @property
    def review_compliance(self) -> str:
        """Review/Verification compliance of this data set with the respective requirements set by the "compliance system" refered to."""
        return self._data.get("common:reviewCompliance")

    @review_compliance.setter
    def review_compliance(self, value: str) -> None:
        """Set common:reviewCompliance."""
        self._data["common:reviewCompliance"] = value

    @property
    def documentation_compliance(self) -> str:
        """Documentation/Reporting compliance of this data set with the respective requirements set by the "compliance system" refered to."""
        return self._data.get("common:documentationCompliance")

    @documentation_compliance.setter
    def documentation_compliance(self, value: str) -> None:
        """Set common:documentationCompliance."""
        self._data["common:documentationCompliance"] = value

    @property
    def quality_compliance(self) -> str:
        """Quality compliance of this data set with the respective requirements set by the "compliance system" refered to."""
        return self._data.get("common:qualityCompliance")

    @quality_compliance.setter
    def quality_compliance(self, value: str) -> None:
        """Set common:qualityCompliance."""
        self._data["common:qualityCompliance"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ComplianceDeclarationsWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplianceDeclarationsWrapper."""

    __slots__ = ()

    @property
    def compliance(self) -> ComplianceWrapper:
        """Access compliance nested object"""
        self._ensure_field("compliance")
        return ComplianceWrapper(self._entity, self._data["compliance"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataQualityIndicatorWrapper(BaseWrapper):
    """Auto-generated wrapper for DataQualityIndicatorWrapper."""

    __slots__ = ()

    @property
    def name(self) -> Optional[str]:
        """Access @name field"""
        return self._data.get("@name")

    @name.setter
    def name(self, value: Optional[str]) -> None:
        """Set @name."""
        if value is None:
            self._data.pop("@name", None)
        else:
            self._data["@name"] = value

    @property
    def value(self) -> Optional[str]:
        """Access @value field"""
        return self._data.get("@value")

    @value.setter
    def value(self, value: Optional[str]) -> None:
        """Set @value."""
        if value is None:
            self._data.pop("@value", None)
        else:
            self._data["@value"] = value


class DataQualityIndicatorsWrapper(BaseWrapper):
    """Auto-generated wrapper for DataQualityIndicatorsWrapper."""

    __slots__ = ()

    @property
    def data_quality_indicator(self) -> DataQualityIndicatorWrapper:
        """Data quality indicators serve to provide the reviewed key information on the data set in a defined, computer-readable (and hence searchable) form. This serves to support LCA practitioners to identify/select the highest quality and most appropriate data sets."""
        self._ensure_field("dataQualityIndicator")
        return DataQualityIndicatorWrapper(self._entity, self._data["dataQualityIndicator"])


class ReviewWrapper(BaseWrapper):
    """Auto-generated wrapper for ReviewWrapper."""

    __slots__ = ()

    @property
    def type(self) -> str:
        """Access @type field"""
        return self._data.get("@type")

    @type.setter
    def type(self, value: str) -> None:
        """Set @type."""
        self._data["@type"] = value

    @property
    def scope(self) -> str:
        """Scope of review regarding which aspects and components of the data set was reviewed or verified. In case of aggregated e.g. LCI results also and on which level of detail (e.g. LCI results only, included unit processes, ...) the review / verification was performed."""
        return self._data.get("scope")

    @scope.setter
    def scope(self, value: str) -> None:
        """Set scope."""
        self._data["scope"] = value

    @property
    def data_quality_indicators(self) -> DataQualityIndicatorsWrapper:
        """Data quality indicators serve to provide the reviewed key information on the data set in a defined, computer-readable (and hence searchable) form. This serves to support LCA practitioners to identify/select the highest quality and most appropriate data sets."""
        self._ensure_field("dataQualityIndicators")
        return DataQualityIndicatorsWrapper(self._entity, self._data["dataQualityIndicators"])

    @property
    def review_details(self) -> MultiLangText:
        """Summary of the review. All the following items should be explicitly addressed: Representativeness, completeness, and precision of Inputs and Outputs for the process in its documented location, technology and time i.e. both completeness of technical model (product, waste, and elementary flows) and completeness of coverage of the relevant problem fields (environmental, human health, resource use) for this specific good, service, or process. Plausibility of data. Correctness and appropriateness of the data set documentation. Appropriateness of system boundaries, cut-off rules, LCI modelling choices such as e.g. allocation, consistency of included processes and of LCI methodology. If the data set comprises pre-calculated LCIA results, the correspondence of the Input and Output elementary flows (including their geographical validity) with the applied LCIA method(s) should be addressed by the reviewer. An overall quality statement on the data set may be included here."""
        return self._get_multi_lang("reviewDetails")

    @property
    def reference_to_name_of_reviewer_and_institution(self) -> Optional[str]:
        """"Contact data set" of reviewer. The full name of reviewer(s) and institution(s) as well as a contact address and/or email should be provided in that contact data set."""
        return self._data.get("common:referenceToNameOfReviewerAndInstitution")

    @reference_to_name_of_reviewer_and_institution.setter
    def reference_to_name_of_reviewer_and_institution(self, value: Optional[str]) -> None:
        """Set common:referenceToNameOfReviewerAndInstitution."""
        if value is None:
            self._data.pop("common:referenceToNameOfReviewerAndInstitution", None)
        else:
            self._data["common:referenceToNameOfReviewerAndInstitution"] = value

    @property
    def other_review_details(self) -> MultiLangText:
        """Further information from the review process, especially comments received from third parties once the data set has been published or additional reviewer comments from an additional external review."""
        return self._get_multi_lang("common:otherReviewDetails")

    @property
    def reference_to_complete_review_report(self) -> Optional[str]:
        """"Source data set" of the complete review report."""
        return self._data.get("common:referenceToCompleteReviewReport")

    @reference_to_complete_review_report.setter
    def reference_to_complete_review_report(self, value: Optional[str]) -> None:
        """Set common:referenceToCompleteReviewReport."""
        if value is None:
            self._data.pop("common:referenceToCompleteReviewReport", None)
        else:
            self._data["common:referenceToCompleteReviewReport"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ValidationWrapper(BaseWrapper):
    """Auto-generated wrapper for ValidationWrapper."""

    __slots__ = ()

    @property
    def review(self) -> ReviewWrapper:
        """Type of review that has been performed regarding independency and type of review process."""
        self._ensure_field("review")
        return ReviewWrapper(self._entity, self._data["review"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class CompletenessElementaryFlowsWrapper(BaseWrapper):
    """Auto-generated wrapper for CompletenessElementaryFlowsWrapper."""

    __slots__ = ()

    @property
    def type(self) -> Optional[str]:
        """Access @type field"""
        return self._data.get("@type")

    @type.setter
    def type(self, value: Optional[str]) -> None:
        """Set @type."""
        if value is None:
            self._data.pop("@type", None)
        else:
            self._data["@type"] = value

    @property
    def value(self) -> Optional[str]:
        """Access @value field"""
        return self._data.get("@value")

    @value.setter
    def value(self, value: Optional[str]) -> None:
        """Set @value."""
        if value is None:
            self._data.pop("@value", None)
        else:
            self._data["@value"] = value


class CompletenessWrapper(BaseWrapper):
    """Auto-generated wrapper for CompletenessWrapper."""

    __slots__ = ()

    @property
    def completeness_product_model(self) -> Optional[str]:
        """Completeness of coverage of relevant product, waste and elementary flows. [Notes: For LCI results and Partly terminated systems this means throughout the underlying product system model. "Relevant" refers to the overall environmental relevance, i.e. for unit processes including the upstream and downstream burdens of product and waste flows.]"""
        return self._data.get("completenessProductModel")

    @completeness_product_model.setter
    def completeness_product_model(self, value: Optional[str]) -> None:
        """Set completenessProductModel."""
        if value is None:
            self._data.pop("completenessProductModel", None)
        else:
            self._data["completenessProductModel"] = value

    @property
    def reference_to_supported_impact_assessment_methods(self) -> Optional[str]:
        """"LCIA methods data sets" that can be applied to the elementary flows in the Inputs and Outputs section, i.e. ALL these flows are referenced by the respective LCIA method data set (if they are of environmental relevance and a characterisation factor is defined for the respective flow). [Note: Applicability is not given if the inventoty contains some elementary flows with the same meaning as referenced in the LCIA method data set but in a different nomenclature (and hence carry no characterisation factor), or if the flows are sum indicators or flow groups that are addressed differently in the LCIA method data set.]"""
        return self._data.get("referenceToSupportedImpactAssessmentMethods")

    @reference_to_supported_impact_assessment_methods.setter
    def reference_to_supported_impact_assessment_methods(self, value: Optional[str]) -> None:
        """Set referenceToSupportedImpactAssessmentMethods."""
        if value is None:
            self._data.pop("referenceToSupportedImpactAssessmentMethods", None)
        else:
            self._data["referenceToSupportedImpactAssessmentMethods"] = value

    @property
    def completeness_elementary_flows(self) -> CompletenessElementaryFlowsWrapper:
        """Completeness of the elementary flows in the Inputs and Outputs section of this data set from impact perspective, regarding addressing the individual mid-point problem field / impact category given. The completeness refers to the state-of-the-art of scientific knowledge whether or not an individual elementary flow contributes to the respective mid-point topic in a relevant way, which is e.g. the basis for the ILCD reference elementary flows. [Note: The "Completeness" statement does not automatically mean that related LCIA methods exist or reference the elementary flows of this data set. Hence for direct applicability of existing LCIA methods, check the field "Supported LCIA method data sets".]"""
        self._ensure_field("completenessElementaryFlows")
        return CompletenessElementaryFlowsWrapper(self._entity, self._data["completenessElementaryFlows"])

    @property
    def completeness_other_problem_field(self) -> MultiLangText:
        """Completeness of coverage of elementary flows that contribute to other problem fields that are named here as free text, preferably using the same terminology as for the specified environmental problems."""
        return self._get_multi_lang("completenessOtherProblemField")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataSourcesTreatmentAndRepresentativenessWrapper(BaseWrapper):
    """Auto-generated wrapper for DataSourcesTreatmentAndRepresentativenessWrapper."""

    __slots__ = ()

    @property
    def data_cut_off_and_completeness_principles(self) -> MultiLangText:
        """Principles applied in data collection regarding completeness of (also intermediate) product and waste flows and of elementary flows. Examples are: cut-off rules, systematic exclusion of infrastructure, services or auxiliaries, etc. systematic exclusion of air in incineration processes, coling water, etc."""
        return self._get_multi_lang("dataCutOffAndCompletenessPrinciples")

    @property
    def deviations_from_cut_off_and_completeness_principles(self) -> MultiLangText:
        """Short description of any deviations from the "Data completeness principles". In case of no (result relevant) deviations, "none" is entered."""
        return self._get_multi_lang("deviationsFromCutOffAndCompletenessPrinciples")

    @property
    def data_selection_and_combination_principles(self) -> MultiLangText:
        """Principles applied in data selection and in combination of data from different sources. Includes brief discussion of consistency of data sources regarding data itself, modelling, appropriateness. In case of averaging: Principles and data selection applied in horizontal and / or vertical averaging."""
        return self._get_multi_lang("dataSelectionAndCombinationPrinciples")

    @property
    def deviations_from_selection_and_combination_principles(self) -> MultiLangText:
        """Short description of any deviations from the "Data selection and combination principles". In case of no (result relevant) deviations, "none" is entered."""
        return self._get_multi_lang("deviationsFromSelectionAndCombinationPrinciples")

    @property
    def data_treatment_and_extrapolations_principles(self) -> MultiLangText:
        """Principles applied regarding methods, sources, and assumptions done in data adjustment including extrapolations of data from another time period, another geographical area, or another technology."""
        return self._get_multi_lang("dataTreatmentAndExtrapolationsPrinciples")

    @property
    def deviations_from_treatment_and_extrapolation_principles(self) -> MultiLangText:
        """Short description of any deviations from the " Data treatment and extrapolations principles". In case of no (result relevant) deviations, "none" is entered. (Note: If data representative for one "Location" is used for another "Location", its original representativity can be indicated here; see field "Percentage supply or production covered".)"""
        return self._get_multi_lang("deviationsFromTreatmentAndExtrapolationPrinciples")

    @property
    def reference_to_data_handling_principles(self) -> Optional[str]:
        """"Source data set"(s) of the source(s) in which the data completeness, selection, combination, treatment, and extrapolations principles' details are described"""
        return self._data.get("referenceToDataHandlingPrinciples")

    @reference_to_data_handling_principles.setter
    def reference_to_data_handling_principles(self, value: Optional[str]) -> None:
        """Set referenceToDataHandlingPrinciples."""
        if value is None:
            self._data.pop("referenceToDataHandlingPrinciples", None)
        else:
            self._data["referenceToDataHandlingPrinciples"] = value

    @property
    def reference_to_data_source(self) -> str:
        """"Source data set"(s) of the source(s) used for deriving/compiling the inventory of this data set e.g. questionnaires, monographies, plant operation protocols, etc. For LCI results and Partly terminated systems the sources for relevant background system data are to be given, too. For parameterised data sets the sources used for the parameterisation / mathematical relations in the section "Mathematical model" are referenced here as well. [Note: If the data set stems from another database or data set publication and is only re-published: identify the origin of a converted data set in "Converted original data set from:" field in section "Data entry by" and its unchanged re-publication in "Unchanged re-publication of:" in the section "Publication and ownership". The data sources used to model a converted or re-published data set are nevertheless to be given here in this field, for transparency reasons.]"""
        return self._data.get("referenceToDataSource")

    @reference_to_data_source.setter
    def reference_to_data_source(self, value: str) -> None:
        """Set referenceToDataSource."""
        self._data["referenceToDataSource"] = value

    @property
    def percentage_supply_or_production_covered(self) -> Optional[str]:
        """Percentage of the overall supply, consumption, or production of the specific good, service, or technology represented by this data set, in the region/market of the stated "Location". For multi-functional processes the market share of the specific technology is stated. If data that is representative for a process operated in one "Location" is used for another "Location", the entry is '0'. The representativity for the original "Location" is documented in the field "Deviation from data treatment and extrapolation principles, explanations"."""
        return self._data.get("percentageSupplyOrProductionCovered")

    @percentage_supply_or_production_covered.setter
    def percentage_supply_or_production_covered(self, value: Optional[str]) -> None:
        """Set percentageSupplyOrProductionCovered."""
        if value is None:
            self._data.pop("percentageSupplyOrProductionCovered", None)
        else:
            self._data["percentageSupplyOrProductionCovered"] = value

    @property
    def annual_supply_or_production_volume(self) -> MultiLangText:
        """Supply / consumption or production volume of the specific good, service, or technology in the region/market of the stated "Location". The market volume is given in absolute numbers per year, in common units, for the stated "Reference year". For multi-fucntional processes the data should be given for all co-functions (good and services)."""
        return self._get_multi_lang("annualSupplyOrProductionVolume")

    @property
    def sampling_procedure(self) -> MultiLangText:
        """Sampling procedure used for quantifying the amounts of Inputs and Outputs. Possible problems in combining different sampling procedures should be mentioned."""
        return self._get_multi_lang("samplingProcedure")

    @property
    def data_collection_period(self) -> MultiLangText:
        """Date(s) or time period(s) when the data was collected. Note that this does NOT refer to e.g. the publication dates of papers or books from which the data may stem, but to the original data collection period."""
        return self._get_multi_lang("dataCollectionPeriod")

    @property
    def uncertainty_adjustments(self) -> MultiLangText:
        """Description of methods, sources, and assumptions made in uncertainty adjustment. [Note: For data sets where the additional uncertainty due to lacking representativeness has been included in the quantified uncertainty values, this field also reports the original representativeness, the additional uncertainty, and the procedure by which the overall uncertainty was assessed or calculated.]"""
        return self._get_multi_lang("uncertaintyAdjustments")

    @property
    def use_advice_for_data_set(self) -> MultiLangText:
        """Specific methodological advice for data set users that requires attention. E.g. on inclusion/exclusion of recycling e.g. in material data sets, specific use phase behavior to be modelled, and other methodological advices. See also field "Technological applicability"."""
        return self._get_multi_lang("useAdviceForDataSet")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class LciMethodAndAllocationWrapper(BaseWrapper):
    """Auto-generated wrapper for LciMethodAndAllocationWrapper."""

    __slots__ = ()

    @property
    def type_of_data_set(self) -> str:
        """Type of the data set regarding systematic inclusion/exclusion of upstream or downstream processes, transparency and internal (hidden) multi-functionality, and the completeness of modelling."""
        return self._data.get("typeOfDataSet")

    @type_of_data_set.setter
    def type_of_data_set(self, value: str) -> None:
        """Set typeOfDataSet."""
        self._data["typeOfDataSet"] = value

    @property
    def lci_method_principle(self) -> Optional[str]:
        """LCI method principle followed in the product system modelling, i.e. regarding using average data (= attributional = non-marginal) or modelling effects in a change-oriented way (= consequential = marginal)."""
        return self._data.get("LCIMethodPrinciple")

    @lci_method_principle.setter
    def lci_method_principle(self, value: Optional[str]) -> None:
        """Set LCIMethodPrinciple."""
        if value is None:
            self._data.pop("LCIMethodPrinciple", None)
        else:
            self._data["LCIMethodPrinciple"] = value

    @property
    def deviations_from_lci_method_principle(self) -> MultiLangText:
        """Short description of any deviations from the general "LCI method principles" and additional explanations. Refers especially to specific processes/cases where the stated "attributional" or "consequential" approach was not applied. Or where deviations were made from any specific rules for applying the "Consequential with attributional components" approach. A reference to the "Intended application" of the data collection can be made here, too. Allocated co-products may be reported here as well. In case of no (quantitatively relevant) deviations from the LCI method principle, "none" should be stated."""
        return self._get_multi_lang("deviationsFromLCIMethodPrinciple")

    @property
    def lci_method_approaches(self) -> Optional[str]:
        """Names briefly the specific approach(es) used in LCI modeling, e.g. allocation, substitution etc. In case of LCI results and Partly terminated system data sets this also covers those applied in the included background system."""
        return self._data.get("LCIMethodApproaches")

    @lci_method_approaches.setter
    def lci_method_approaches(self, value: Optional[str]) -> None:
        """Set LCIMethodApproaches."""
        if value is None:
            self._data.pop("LCIMethodApproaches", None)
        else:
            self._data["LCIMethodApproaches"] = value

    @property
    def deviations_from_lci_method_approaches(self) -> MultiLangText:
        """Description of relevant deviations from the applied approaches as well as of the relevant specific approaches that were applied, including in an possibly included background system. Further explanations and details of the allocation, substitution and other consequential approaches applied for relevant processes, e.g. how the marginal substitute was identified, year and region of which market prices were used in market allocation, i.e. method, procedure, data/information details. In case of no (result relevant) deviations from the before stated LCI method approaches, and in case of no need for further explanations, "none" is entered."""
        return self._get_multi_lang("deviationsFromLCIMethodApproaches")

    @property
    def modelling_constants(self) -> MultiLangText:
        """Short identification and description of constants applied in LCI modelling other than allocation / substitution, e.g. systematic setting of recycling quota, use of gross or net calorific value, etc."""
        return self._get_multi_lang("modellingConstants")

    @property
    def deviations_from_modelling_constants(self) -> MultiLangText:
        """Short description of data set specific deviations from the "Modelling constants" if any, including in the possibly included background system."""
        return self._get_multi_lang("deviationsFromModellingConstants")

    @property
    def reference_to_lca_method_details(self) -> Optional[str]:
        """"Source data set"(s) where the generally used LCA methods including the LCI method principles and specific approaches, the modelling constants details, as well as any other applied methodological conventions are described."""
        return self._data.get("referenceToLCAMethodDetails")

    @reference_to_lca_method_details.setter
    def reference_to_lca_method_details(self, value: Optional[str]) -> None:
        """Set referenceToLCAMethodDetails."""
        if value is None:
            self._data.pop("referenceToLCAMethodDetails", None)
        else:
            self._data["referenceToLCAMethodDetails"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ModellingAndValidationWrapper(BaseWrapper):
    """Auto-generated wrapper for ModellingAndValidationWrapper."""

    __slots__ = ()

    @property
    def lci_method_and_allocation(self) -> LciMethodAndAllocationWrapper:
        """Access LCIMethodAndAllocation nested object"""
        self._ensure_field("LCIMethodAndAllocation")
        return LciMethodAndAllocationWrapper(self._entity, self._data["LCIMethodAndAllocation"])

    @property
    def data_sources_treatment_and_representativeness(self) -> DataSourcesTreatmentAndRepresentativenessWrapper:
        """Access dataSourcesTreatmentAndRepresentativeness nested object"""
        self._ensure_field("dataSourcesTreatmentAndRepresentativeness")
        return DataSourcesTreatmentAndRepresentativenessWrapper(self._entity, self._data["dataSourcesTreatmentAndRepresentativeness"])

    @property
    def completeness(self) -> CompletenessWrapper:
        """Access completeness nested object"""
        self._ensure_field("completeness")
        return CompletenessWrapper(self._entity, self._data["completeness"])

    @property
    def validation(self) -> ValidationWrapper:
        """Review information on LCIA method."""
        self._ensure_field("validation")
        return ValidationWrapper(self._entity, self._data["validation"])

    @property
    def compliance_declarations(self) -> ComplianceDeclarationsWrapper:
        """Statements on compliance of several data set aspects with compliance requirements as defined by the referenced compliance system (e.g. an EPD scheme, handbook of a national or international data network such as the ILCD, etc.)."""
        self._ensure_field("complianceDeclarations")
        return ComplianceDeclarationsWrapper(self._entity, self._data["complianceDeclarations"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class VariableParameterWrapper(BaseWrapper):
    """Auto-generated wrapper for VariableParameterWrapper."""

    __slots__ = ()

    @property
    def name(self) -> Optional[str]:
        """Name of the variable parameter in the mathematical model."""
        return self._data.get("@name")

    @name.setter
    def name(self, value: Optional[str]) -> None:
        """Set @name."""
        if value is None:
            self._data.pop("@name", None)
        else:
            self._data["@name"] = value

    @property
    def formula(self) -> Optional[str]:
        """Formula of the variable parameter in the mathematical model."""
        return self._data.get("formula")

    @formula.setter
    def formula(self, value: Optional[str]) -> None:
        """Set formula."""
        if value is None:
            self._data.pop("formula", None)
        else:
            self._data["formula"] = value

    @property
    def mean_value(self) -> Optional[str]:
        """Comment on the variable parameter in the mathematical model."""
        return self._data.get("meanValue")

    @mean_value.setter
    def mean_value(self, value: Optional[str]) -> None:
        """Set meanValue."""
        if value is None:
            self._data.pop("meanValue", None)
        else:
            self._data["meanValue"] = value

    @property
    def minimum_value(self) -> Optional[str]:
        """Comment on the variable parameter in the mathematical model."""
        return self._data.get("minimumValue")

    @minimum_value.setter
    def minimum_value(self, value: Optional[str]) -> None:
        """Set minimumValue."""
        if value is None:
            self._data.pop("minimumValue", None)
        else:
            self._data["minimumValue"] = value

    @property
    def maximum_value(self) -> Optional[str]:
        """Comment on the variable parameter in the mathematical model."""
        return self._data.get("maximumValue")

    @maximum_value.setter
    def maximum_value(self, value: Optional[str]) -> None:
        """Set maximumValue."""
        if value is None:
            self._data.pop("maximumValue", None)
        else:
            self._data["maximumValue"] = value

    @property
    def uncertainty_distribution_type(self) -> Optional[str]:
        """Defines the kind of uncertainty distribution that is valid for this particular object or parameter."""
        return self._data.get("uncertaintyDistributionType")

    @uncertainty_distribution_type.setter
    def uncertainty_distribution_type(self, value: Optional[str]) -> None:
        """Set uncertaintyDistributionType."""
        if value is None:
            self._data.pop("uncertaintyDistributionType", None)
        else:
            self._data["uncertaintyDistributionType"] = value

    @property
    def relative_standard_deviation95_in(self) -> Optional[str]:
        """Access relativeStandardDeviation95In field"""
        return self._data.get("relativeStandardDeviation95In")

    @relative_standard_deviation95_in.setter
    def relative_standard_deviation95_in(self, value: Optional[str]) -> None:
        """Set relativeStandardDeviation95In."""
        if value is None:
            self._data.pop("relativeStandardDeviation95In", None)
        else:
            self._data["relativeStandardDeviation95In"] = value

    @property
    def comment(self) -> MultiLangText:
        """Access comment multi-language field"""
        return self._get_multi_lang("comment")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class MathematicalRelationsWrapper(BaseWrapper):
    """Auto-generated wrapper for MathematicalRelationsWrapper."""

    __slots__ = ()

    @property
    def model_description(self) -> MultiLangText:
        """Description of the model(s) represented in this section of mathematical relations. Can cover information on restrictions, model strenghts and weaknesses, etc. (Note: Also see information provided on the level of the individual formula in field "Comment" and in the general process description in the fields in section "Technology".)"""
        return self._get_multi_lang("modelDescription")

    @property
    def variable_parameter(self) -> VariableParameterWrapper:
        """Access variableParameter nested object"""
        self._ensure_field("variableParameter")
        return VariableParameterWrapper(self._entity, self._data["variableParameter"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class TechnologyWrapper(BaseWrapper):
    """Auto-generated wrapper for TechnologyWrapper."""

    __slots__ = ()

    @property
    def technology_description_and_included_processes(self) -> MultiLangText:
        """Description of the technological characteristics including operating conditions of the process or product system. For the latter this includes the relevant upstream and downstream processes included in the data set. Professional terminology should be used."""
        return self._get_multi_lang("technologyDescriptionAndIncludedProcesses")

    @property
    def reference_to_included_processes(self) -> Optional[str]:
        """"Process data set(s)" included in this data set, if any and available as separate data set(s)."""
        return self._data.get("referenceToIncludedProcesses")

    @reference_to_included_processes.setter
    def reference_to_included_processes(self, value: Optional[str]) -> None:
        """Set referenceToIncludedProcesses."""
        if value is None:
            self._data.pop("referenceToIncludedProcesses", None)
        else:
            self._data["referenceToIncludedProcesses"] = value

    @property
    def technological_applicability(self) -> MultiLangText:
        """Description of the intended / possible applications of the good, service, or process. E.g. for which type of products the material, represented by this data set, is used. Examples: "This high purity chemical is used for analytical laboratories only." or "This technical quality bulk chemical is used for large scale synthesis in chemical industry.". Or: "This truck is used only for long-distance transport of liquid bulk chemicals"."""
        return self._get_multi_lang("technologicalApplicability")

    @property
    def reference_to_technology_pictogramme(self) -> Optional[str]:
        """"Source data set" of the pictogramme of the good, service, technogy, plant etc. represented by this data set. For use in graphical user interfaces of LCA software."""
        return self._data.get("referenceToTechnologyPictogramme")

    @reference_to_technology_pictogramme.setter
    def reference_to_technology_pictogramme(self, value: Optional[str]) -> None:
        """Set referenceToTechnologyPictogramme."""
        if value is None:
            self._data.pop("referenceToTechnologyPictogramme", None)
        else:
            self._data["referenceToTechnologyPictogramme"] = value

    @property
    def reference_to_technology_flow_diagramm_or_picture(self) -> Optional[str]:
        """"Source data set" of the flow diagramm(s) and/or photo(s) of the good, service, technology, plant etc represented by this data set. For clearer illustration and documentation of data set."""
        return self._data.get("referenceToTechnologyFlowDiagrammOrPicture")

    @reference_to_technology_flow_diagramm_or_picture.setter
    def reference_to_technology_flow_diagramm_or_picture(self, value: Optional[str]) -> None:
        """Set referenceToTechnologyFlowDiagrammOrPicture."""
        if value is None:
            self._data.pop("referenceToTechnologyFlowDiagrammOrPicture", None)
        else:
            self._data["referenceToTechnologyFlowDiagrammOrPicture"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class SubLocationOfOperationSupplyOrProductionWrapper(BaseWrapper):
    """Auto-generated wrapper for SubLocationOfOperationSupplyOrProductionWrapper."""

    __slots__ = ()

    @property
    def sub_location(self) -> Optional[str]:
        """Access @subLocation field"""
        return self._data.get("@subLocation")

    @sub_location.setter
    def sub_location(self, value: Optional[str]) -> None:
        """Set @subLocation."""
        if value is None:
            self._data.pop("@subLocation", None)
        else:
            self._data["@subLocation"] = value

    @property
    def latitude_and_longitude(self) -> Optional[str]:
        """Geographical latitude and longitude reference of "Location" / "Sub-location". For area-type locations (e.g. countries, continents) the field is empty."""
        return self._data.get("@latitudeAndLongitude")

    @latitude_and_longitude.setter
    def latitude_and_longitude(self, value: Optional[str]) -> None:
        """Set @latitudeAndLongitude."""
        if value is None:
            self._data.pop("@latitudeAndLongitude", None)
        else:
            self._data["@latitudeAndLongitude"] = value

    @property
    def description_of_restrictions(self) -> MultiLangText:
        """Further explanations about additional aspects of the location: e.g. a company and/or site description and address, whether for certain sub-areas within the "Location" the data set is not valid, whether data is only valid for certain regions within the location indicated, or whether certain elementary flows or intermediate product flows are extrapolated from another geographical area."""
        return self._get_multi_lang("descriptionOfRestrictions")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class LocationOfOperationSupplyOrProductionWrapper(BaseWrapper):
    """Auto-generated wrapper for LocationOfOperationSupplyOrProductionWrapper."""

    __slots__ = ()

    @property
    def location(self) -> str:
        """Access @location field"""
        return self._data.get("@location")

    @location.setter
    def location(self, value: str) -> None:
        """Set @location."""
        self._data["@location"] = value

    @property
    def latitude_and_longitude(self) -> Optional[str]:
        """Geographical latitude and longitude reference of "Location" / "Sub-location". For area-type locations (e.g. countries, continents) the field is empty."""
        return self._data.get("@latitudeAndLongitude")

    @latitude_and_longitude.setter
    def latitude_and_longitude(self, value: Optional[str]) -> None:
        """Set @latitudeAndLongitude."""
        if value is None:
            self._data.pop("@latitudeAndLongitude", None)
        else:
            self._data["@latitudeAndLongitude"] = value

    @property
    def description_of_restrictions(self) -> MultiLangText:
        """Further explanations about additional aspects of the location: e.g. a company and/or site description and address, whether for certain sub-areas within the "Location" the data set is not valid, whether data is only valid for certain regions within the location indicated, or whether certain elementary flows or intermediate product flows are extrapolated from another geographical area."""
        return self._get_multi_lang("descriptionOfRestrictions")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class GeographyWrapper(BaseWrapper):
    """Auto-generated wrapper for GeographyWrapper."""

    __slots__ = ()

    @property
    def location_of_operation_supply_or_production(self) -> LocationOfOperationSupplyOrProductionWrapper:
        """Location, country or region the data set represents. [Note 1: This field does not refer to e.g. the country in which a specific site is located that is represented by this data set but to the actually represented country, region, or site. Note 2: Entry can be of type "two-letter ISO 3166 country code" for countries, "seven-letter regional codes" for regions or continents, or "market areas and market organisations", as predefined for the ILCD. Also a name for e.g. a specific plant etc. can be given here (e.g. "FR, Lyon, XY Company, Z Site"; user defined). Note 3: The fact whether the entry refers to production or to consumption / supply has to be stated in the name-field "Mix and location types" e.g. as "Production mix".]"""
        self._ensure_field("locationOfOperationSupplyOrProduction")
        return LocationOfOperationSupplyOrProductionWrapper(self._entity, self._data["locationOfOperationSupplyOrProduction"])

    @property
    def sub_location_of_operation_supply_or_production(self) -> SubLocationOfOperationSupplyOrProductionWrapper:
        """One or more geographical sub-unit(s) of the stated "Location". Such sub-units can be e.g. the sampling sites of a company-average data set, the countries of a region-average data set, or specific sites in a country-average data set. [Note: For single site data sets this field is empty and the site is named in the "Location" field.]"""
        self._ensure_field("subLocationOfOperationSupplyOrProduction")
        return SubLocationOfOperationSupplyOrProductionWrapper(self._entity, self._data["subLocationOfOperationSupplyOrProduction"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class TimeWrapper(BaseWrapper):
    """Auto-generated wrapper for TimeWrapper."""

    __slots__ = ()

    @property
    def reference_year(self) -> str:
        """Reference year when the emission is assumed to take place, i.e. the start year of the time period for which the impact is modelled. For time-independent models "time independent" should be stated."""
        return self._data.get("common:referenceYear")

    @reference_year.setter
    def reference_year(self, value: str) -> None:
        """Set common:referenceYear."""
        self._data["common:referenceYear"] = value

    @property
    def data_set_valid_until(self) -> Optional[str]:
        """End year of the time period for which the data set is still valid / sufficiently representative. This date also determines when a data set revision / remodelling is required or recommended due to expected relevant changes in environmentally or technically relevant inventory values, including in the background system."""
        return self._data.get("common:dataSetValidUntil")

    @data_set_valid_until.setter
    def data_set_valid_until(self, value: Optional[str]) -> None:
        """Set common:dataSetValidUntil."""
        if value is None:
            self._data.pop("common:dataSetValidUntil", None)
        else:
            self._data["common:dataSetValidUntil"] = value

    @property
    def time_representativeness_description(self) -> MultiLangText:
        """Description of the valid time span of the data set including information on limited usability within sub-time spans, if any."""
        return self._get_multi_lang("common:timeRepresentativenessDescription")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class QuantitativeReferenceWrapper(BaseWrapper):
    """Auto-generated wrapper for QuantitativeReferenceWrapper."""

    __slots__ = ()

    @property
    def type(self) -> str:
        """Access @type field"""
        return self._data.get("@type")

    @type.setter
    def type(self, value: str) -> None:
        """Set @type."""
        self._data["@type"] = value

    @property
    def reference_to_reference_flow(self) -> str:
        """Access referenceToReferenceFlow field"""
        return self._data.get("referenceToReferenceFlow")

    @reference_to_reference_flow.setter
    def reference_to_reference_flow(self, value: str) -> None:
        """Set referenceToReferenceFlow."""
        self._data["referenceToReferenceFlow"] = value

    @property
    def functional_unit_or_other(self) -> MultiLangText:
        """Access functionalUnitOrOther multi-language field"""
        return self._get_multi_lang("functionalUnitOrOther")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassificationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationWrapper."""

    __slots__ = ()

    @property
    def class_(self) -> str:
        """Access common:class field"""
        return self._data.get("common:class")

    @class_.setter
    def class_(self, value: str) -> None:
        """Set common:class."""
        self._data["common:class"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassificationInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationInformationWrapper."""

    __slots__ = ()

    @property
    def classification(self) -> ClassificationWrapper:
        """Optional statistical or other classification of the data set. Typically also used for structuring LCA databases."""
        self._ensure_field("common:classification")
        return ClassificationWrapper(self._entity, self._data["common:classification"])


class ComplementingProcessesWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplementingProcessesWrapper."""

    __slots__ = ()

    @property
    def reference_to_complementing_process(self) -> Optional[str]:
        """Access referenceToComplementingProcess field"""
        return self._data.get("referenceToComplementingProcess")

    @reference_to_complementing_process.setter
    def reference_to_complementing_process(self, value: Optional[str]) -> None:
        """Set referenceToComplementingProcess."""
        if value is None:
            self._data.pop("referenceToComplementingProcess", None)
        else:
            self._data["referenceToComplementingProcess"] = value


class NameWrapper(BaseWrapper):
    """Auto-generated wrapper for NameWrapper."""

    __slots__ = ()

    @property
    def base_name(self) -> MultiLangText:
        """Access baseName multi-language field"""
        return self._get_multi_lang("baseName")

    @property
    def treatment_standards_routes(self) -> MultiLangText:
        """Access treatmentStandardsRoutes multi-language field"""
        return self._get_multi_lang("treatmentStandardsRoutes")

    @property
    def mix_and_location_types(self) -> MultiLangText:
        """Access mixAndLocationTypes multi-language field"""
        return self._get_multi_lang("mixAndLocationTypes")

    @property
    def functional_unit_flow_properties(self) -> MultiLangText:
        """Access functionalUnitFlowProperties multi-language field"""
        return self._get_multi_lang("functionalUnitFlowProperties")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataSetInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for DataSetInformationWrapper."""

    __slots__ = ()

    @property
    def uuid(self) -> str:
        """Automatically generated Universally Unique Identifier of this data set. Together with the "Data set version", the UUID uniquely identifies each data set."""
        return self._data.get("common:UUID")

    @uuid.setter
    def uuid(self, value: str) -> None:
        """Set common:UUID."""
        self._data["common:UUID"] = value

    @property
    def name(self) -> NameWrapper:
        """General descriptive and specifying name of the process."""
        self._ensure_field("name")
        return NameWrapper(self._entity, self._data["name"])

    @property
    def identifier_of_sub_data_set(self) -> Optional[str]:
        """Identifier of a sub-set of a complete process data set. This can be the life cycle stage that a data set covers (such as used in EPDs for modular LCI reporting, with the inventory split up into "resource extraction stage", "production stage", "use stage" and "end-of-life stage"). Or it can be e.g. the type of emission source from which the elementary flows of the Inputs and Outputs stems (e.g. "incineration-related", "transport-related", etc.). Together with the field "Complementing processes" this allows to split up a process data set into a number of clearly identified data sets, each carrying only a part of the inventory and that together represent the complete inventory. Care has to be taken when naming the reference flow, to avoid misinterpretation."""
        return self._data.get("identifierOfSubDataSet")

    @identifier_of_sub_data_set.setter
    def identifier_of_sub_data_set(self, value: Optional[str]) -> None:
        """Set identifierOfSubDataSet."""
        if value is None:
            self._data.pop("identifierOfSubDataSet", None)
        else:
            self._data["identifierOfSubDataSet"] = value

    @property
    def synonyms(self) -> MultiLangText:
        """Synonyms / alternative names / brands of the good, service, or process. Separated by semicolon."""
        return self._get_multi_lang("common:synonyms")

    @property
    def complementing_processes(self) -> ComplementingProcessesWrapper:
        """Access complementingProcesses nested object"""
        self._ensure_field("complementingProcesses")
        return ComplementingProcessesWrapper(self._entity, self._data["complementingProcesses"])

    @property
    def classification_information(self) -> ClassificationInformationWrapper:
        """Hierarchical or flat classification of the good, service or function that is provided by this life cycle model; typically used to structure database contents in LCA software, among other purposes. (Note: This entry is NOT required for the identification of a Life cycle model, but it should nevertheless be avoided to use identical names for Life cycle model data sets in the same class. The ILCD classifications are defined in the ILCDClassifications.xml file, for common use.)"""
        self._ensure_field("classificationInformation")
        return ClassificationInformationWrapper(self._entity, self._data["classificationInformation"])

    @property
    def general_comment(self) -> MultiLangText:
        """Free text for general information about the Flow data set. It may contain information about e.g. the use of the substance, good, service or process in a specific technology or industry-context, information sources used, data selection principles etc."""
        return self._get_multi_lang("common:generalComment")

    @property
    def reference_to_external_documentation(self) -> Optional[str]:
        """"Source data set(s)" of detailed LCA study on the process or product represented by this data set, as well as documents / files with overarching documentative information on technology, geographical and / or time aspects etc. (e.g. basic engineering studies, process simulation results, patents, plant documentation, model behind the parameterisation of the "Mathematical model" section, etc.) (Note: can indirectly reference to digital file.)"""
        return self._data.get("referenceToExternalDocumentation")

    @reference_to_external_documentation.setter
    def reference_to_external_documentation(self, value: Optional[str]) -> None:
        """Set referenceToExternalDocumentation."""
        if value is None:
            self._data.pop("referenceToExternalDocumentation", None)
        else:
            self._data["referenceToExternalDocumentation"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ProcessInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for ProcessInformationWrapper."""

    __slots__ = ()

    @property
    def data_set_information(self) -> DataSetInformationWrapper:
        """General data set information. Section covers all single fields in the ISO/TS 14048 "Process description", which are not part of the other sub-sections. In ISO/TS 14048 no own sub-section is foreseen for these entries."""
        self._ensure_field("dataSetInformation")
        return DataSetInformationWrapper(self._entity, self._data["dataSetInformation"])

    @property
    def quantitative_reference(self) -> QuantitativeReferenceWrapper:
        """This section names the quantitative reference used for this data set, i.e. the reference to which the inputs and outputs quantiatively relate."""
        self._ensure_field("quantitativeReference")
        return QuantitativeReferenceWrapper(self._entity, self._data["quantitativeReference"])

    @property
    def time(self) -> TimeWrapper:
        """Access time nested object"""
        self._ensure_field("time")
        return TimeWrapper(self._entity, self._data["time"])

    @property
    def geography(self) -> GeographyWrapper:
        """Access geography nested object"""
        self._ensure_field("geography")
        return GeographyWrapper(self._entity, self._data["geography"])

    @property
    def technology(self) -> TechnologyWrapper:
        """Access technology nested object"""
        self._ensure_field("technology")
        return TechnologyWrapper(self._entity, self._data["technology"])

    @property
    def mathematical_relations(self) -> MathematicalRelationsWrapper:
        """Access mathematicalRelations nested object"""
        self._ensure_field("mathematicalRelations")
        return MathematicalRelationsWrapper(self._entity, self._data["mathematicalRelations"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ProcessesDataSetWrapper(BaseWrapper):
    """Auto-generated wrapper for ProcessesDataSetWrapper."""

    __slots__ = ()

    @property
    def version(self) -> str:
        """Access @version field"""
        return self._data.get("@version")

    @version.setter
    def version(self, value: str) -> None:
        """Set @version."""
        self._data["@version"] = value

    @property
    def locations(self) -> str:
        """Access @locations field"""
        return self._data.get("@locations")

    @locations.setter
    def locations(self, value: str) -> None:
        """Set @locations."""
        self._data["@locations"] = value

    @property
    def schema_location(self) -> str:
        """http://lca.jrc.it/ILCD/Process ../../schemas/ILCD_ProcessDataSet.xsd"""
        return self._data.get("@xsi:schemaLocation")

    @schema_location.setter
    def schema_location(self, value: str) -> None:
        """Set @xsi:schemaLocation."""
        self._data["@xsi:schemaLocation"] = value

    @property
    def process_information(self) -> ProcessInformationWrapper:
        """Corresponds to the ISO/TS 14048 section "Process description". It comprises the following six sub-sections: 1) "Data set information" for data set identification and overarching information items, 2) "Quantitative reference", 3) "Time", 4) "Geography", 5) "Technology" and 6) "Mathematical relations"."""
        self._ensure_field("processInformation")
        return ProcessInformationWrapper(self._entity, self._data["processInformation"])

    @property
    def modelling_and_validation(self) -> ModellingAndValidationWrapper:
        """Access modellingAndValidation nested object"""
        self._ensure_field("modellingAndValidation")
        return ModellingAndValidationWrapper(self._entity, self._data["modellingAndValidation"])

    @property
    def administrative_information(self) -> AdministrativeInformationWrapper:
        """Information on data set management and administration."""
        self._ensure_field("administrativeInformation")
        return AdministrativeInformationWrapper(self._entity, self._data["administrativeInformation"])

    @property
    def exchanges(self) -> ExchangesWrapper:
        """Access exchanges nested object"""
        self._ensure_field("exchanges")
        return ExchangesWrapper(self._entity, self._data["exchanges"])

    @property
    def lcia_results(self) -> LciaResultsWrapper:
        """Access LCIAResults nested object"""
        self._ensure_field("LCIAResults")
        return LciaResultsWrapper(self._entity, self._data["LCIAResults"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value
