"""
Auto-generated typed wrappers for flows entity.

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated from JSON schemas.
To regenerate, run: python scripts/generate_types_v2.py
"""

from typing import Optional

from tidas_sdk.core.typed_access import BaseWrapper, MultiLangText



class FlowPropertyWrapper(BaseWrapper):
    """Auto-generated wrapper for FlowPropertyWrapper."""

    __slots__ = ()

    @property
    def data_set_internal_id(self) -> str:
        """Automated entry: internal ID, used in the "Quantitative reference" section to identify the reference flow property."""
        return self._data.get("@dataSetInternalID")

    @data_set_internal_id.setter
    def data_set_internal_id(self, value: str) -> None:
        """Set @dataSetInternalID."""
        self._data["@dataSetInternalID"] = value

    @property
    def reference_to_flow_property_data_set(self) -> str:
        """Access referenceToFlowPropertyDataSet field"""
        return self._data.get("referenceToFlowPropertyDataSet")

    @reference_to_flow_property_data_set.setter
    def reference_to_flow_property_data_set(self, value: str) -> None:
        """Set referenceToFlowPropertyDataSet."""
        self._data["referenceToFlowPropertyDataSet"] = value

    @property
    def mean_value(self) -> str:
        """Value for the flow expressed in this flow property in relationship to the the value of the flow expressed in its reference flow property (see field "Reference to reference flow property" in the "Quantitative reference" section). [Notes and examples: If the product flow "Diesel" is expressed by default in "Mass" (= reference flow property) and "kg" (= corresponding reference unit), the value that would be stated here for an additional flow property e.g. "Net calorific value" would be "42.5", as this flow property has the reference unit "MJ" and Diesel has a net calorific value of 42.5 MJ per 1 kg. It is recommended to report only significant digits of the value.]"""
        return self._data.get("meanValue")

    @mean_value.setter
    def mean_value(self, value: str) -> None:
        """Set meanValue."""
        self._data["meanValue"] = value

    @property
    def minimum_value(self) -> Optional[str]:
        """Minimum value of this flow property in case uncertainty distribution is uniform or triangular."""
        return self._data.get("minimumValue")

    @minimum_value.setter
    def minimum_value(self, value: Optional[str]) -> None:
        """Set minimumValue."""
        if value is None:
            self._data.pop("minimumValue", None)
        else:
            self._data["minimumValue"] = value

    @property
    def maximum_value(self) -> Optional[str]:
        """Maximum value of this flow property in case uncertainty distribution is uniform or triangular."""
        return self._data.get("maximumValue")

    @maximum_value.setter
    def maximum_value(self, value: Optional[str]) -> None:
        """Set maximumValue."""
        if value is None:
            self._data.pop("maximumValue", None)
        else:
            self._data["maximumValue"] = value

    @property
    def uncertainty_distribution_type(self) -> Optional[str]:
        """Access uncertaintyDistributionType field"""
        return self._data.get("uncertaintyDistributionType")

    @uncertainty_distribution_type.setter
    def uncertainty_distribution_type(self, value: Optional[str]) -> None:
        """Set uncertaintyDistributionType."""
        if value is None:
            self._data.pop("uncertaintyDistributionType", None)
        else:
            self._data["uncertaintyDistributionType"] = value

    @property
    def relative_standard_deviation95_in(self) -> Optional[str]:
        """The resulting overall uncertainty of the calculated variable value considering uncertainty of measurements, modelling, appropriateness etc. [Notes: For log-normal distribution the square of the geometric standard deviation (SDg^2) is stated. Mean value times SDg^2 equals the 97.5% value (= Maximum value), Mean value divided by SDg^2 equals the 2.5% value (= Minimum value). For normal distribution the doubled standard deviation value (2*SD) is entered. Mean value plus 2*SD equals 97.5% value (= Maximum value), Mean value minus 2*SD equals 2.5% value (= Minimum value). This data field remains empty when uniform or triangular uncertainty distribution is applied.]"""
        return self._data.get("relativeStandardDeviation95In")

    @relative_standard_deviation95_in.setter
    def relative_standard_deviation95_in(self, value: Optional[str]) -> None:
        """Set relativeStandardDeviation95In."""
        if value is None:
            self._data.pop("relativeStandardDeviation95In", None)
        else:
            self._data["relativeStandardDeviation95In"] = value

    @property
    def data_derivation_type_status(self) -> Optional[str]:
        """Access dataDerivationTypeStatus field"""
        return self._data.get("dataDerivationTypeStatus")

    @data_derivation_type_status.setter
    def data_derivation_type_status(self, value: Optional[str]) -> None:
        """Set dataDerivationTypeStatus."""
        if value is None:
            self._data.pop("dataDerivationTypeStatus", None)
        else:
            self._data["dataDerivationTypeStatus"] = value

    @property
    def general_comment(self) -> MultiLangText:
        """Access generalComment multi-language field"""
        return self._get_multi_lang("generalComment")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class FlowPropertiesWrapper(BaseWrapper):
    """Auto-generated wrapper for FlowPropertiesWrapper."""

    __slots__ = ()

    @property
    def flow_property(self) -> FlowPropertyWrapper:
        """Access flowProperty nested object"""
        self._ensure_field("flowProperty")
        return FlowPropertyWrapper(self._entity, self._data["flowProperty"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class PublicationAndOwnershipWrapper(BaseWrapper):
    """Auto-generated wrapper for PublicationAndOwnershipWrapper."""

    __slots__ = ()

    @property
    def data_set_version(self) -> str:
        """Version number of data set. First two digits refer to major updates, the second two digits to minor revisions and error corrections etc. The third three digits are intended for automatic and internal counting of versions during data set development. Together with the data set's UUID, the "Data set version" uniquely identifies each data set."""
        return self._data.get("common:dataSetVersion")

    @data_set_version.setter
    def data_set_version(self, value: str) -> None:
        """Set common:dataSetVersion."""
        self._data["common:dataSetVersion"] = value

    @property
    def reference_to_preceding_data_set_version(self) -> Optional[str]:
        """Last preceding data set, which was replaced by this version. Either a URI of that data set (i.e. an internet address) or its UUID plus version number is given (or both)."""
        return self._data.get("common:referenceToPrecedingDataSetVersion")

    @reference_to_preceding_data_set_version.setter
    def reference_to_preceding_data_set_version(self, value: Optional[str]) -> None:
        """Set common:referenceToPrecedingDataSetVersion."""
        if value is None:
            self._data.pop("common:referenceToPrecedingDataSetVersion", None)
        else:
            self._data["common:referenceToPrecedingDataSetVersion"] = value

    @property
    def permanent_data_set_uri(self) -> Optional[str]:
        """URI (i.e. an internet address) of the original of this data set. [Note: This equally globally unique identifier supports users and software tools to identify and retrieve the original version of a data set via the internet or to check for available updates. The URI must not represent an existing WWW address, but it should be unique and point to the data access point, e.g. by combining the data owner's www path with the data set's UUID, e.g. http://www.mycompany.com/lca/processes/50f12420-8855-12db-b606-0900210c9a66.]"""
        return self._data.get("common:permanentDataSetURI")

    @permanent_data_set_uri.setter
    def permanent_data_set_uri(self, value: Optional[str]) -> None:
        """Set common:permanentDataSetURI."""
        if value is None:
            self._data.pop("common:permanentDataSetURI", None)
        else:
            self._data["common:permanentDataSetURI"] = value

    @property
    def reference_to_ownership_of_data_set(self) -> str:
        """"Contact data set" of the person or entity who owns this data set. (Note: this is not necessarily the publisher of the data set.)"""
        return self._data.get("common:referenceToOwnershipOfDataSet")

    @reference_to_ownership_of_data_set.setter
    def reference_to_ownership_of_data_set(self, value: str) -> None:
        """Set common:referenceToOwnershipOfDataSet."""
        self._data["common:referenceToOwnershipOfDataSet"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataEntryByWrapper(BaseWrapper):
    """Auto-generated wrapper for DataEntryByWrapper."""

    __slots__ = ()

    @property
    def time_stamp(self) -> str:
        """Date and time stamp of data set generation, typically an automated entry ("last saved")."""
        return self._data.get("common:timeStamp")

    @time_stamp.setter
    def time_stamp(self, value: str) -> None:
        """Set common:timeStamp."""
        self._data["common:timeStamp"] = value

    @property
    def reference_to_data_set_format(self) -> str:
        """"Source data set" of the used version of the ILCD format. If additional data format fields have been integrated into the data set file, using the "namespace" option, the used format namespace(s) are to be given. This is the case if the data sets carries additional information as specified by other, particular LCA formats, e.g. of other database networks or LCA softwares."""
        return self._data.get("common:referenceToDataSetFormat")

    @reference_to_data_set_format.setter
    def reference_to_data_set_format(self, value: str) -> None:
        """Set common:referenceToDataSetFormat."""
        self._data["common:referenceToDataSetFormat"] = value

    @property
    def reference_to_person_or_entity_entering_the_data(self) -> Optional[str]:
        """"Contact data set" of the responsible person or entity that has documented this data set, i.e. entered the data and the descriptive information."""
        return self._data.get("common:referenceToPersonOrEntityEnteringTheData")

    @reference_to_person_or_entity_entering_the_data.setter
    def reference_to_person_or_entity_entering_the_data(self, value: Optional[str]) -> None:
        """Set common:referenceToPersonOrEntityEnteringTheData."""
        if value is None:
            self._data.pop("common:referenceToPersonOrEntityEnteringTheData", None)
        else:
            self._data["common:referenceToPersonOrEntityEnteringTheData"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class AdministrativeInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for AdministrativeInformationWrapper."""

    __slots__ = ()

    @property
    def data_entry_by(self) -> DataEntryByWrapper:
        """Access dataEntryBy nested object"""
        self._ensure_field("dataEntryBy")
        return DataEntryByWrapper(self._entity, self._data["dataEntryBy"])

    @property
    def publication_and_ownership(self) -> PublicationAndOwnershipWrapper:
        """Access publicationAndOwnership nested object"""
        self._ensure_field("publicationAndOwnership")
        return PublicationAndOwnershipWrapper(self._entity, self._data["publicationAndOwnership"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ComplianceWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplianceWrapper."""

    __slots__ = ()

    @property
    def reference_to_compliance_system(self) -> str:
        """Access common:referenceToComplianceSystem field"""
        return self._data.get("common:referenceToComplianceSystem")

    @reference_to_compliance_system.setter
    def reference_to_compliance_system(self, value: str) -> None:
        """Set common:referenceToComplianceSystem."""
        self._data["common:referenceToComplianceSystem"] = value

    @property
    def approval_of_overall_compliance(self) -> str:
        """Access common:approvalOfOverallCompliance field"""
        return self._data.get("common:approvalOfOverallCompliance")

    @approval_of_overall_compliance.setter
    def approval_of_overall_compliance(self, value: str) -> None:
        """Set common:approvalOfOverallCompliance."""
        self._data["common:approvalOfOverallCompliance"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ComplianceDeclarationsWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplianceDeclarationsWrapper."""

    __slots__ = ()

    @property
    def compliance(self) -> ComplianceWrapper:
        """Access compliance nested object"""
        self._ensure_field("compliance")
        return ComplianceWrapper(self._entity, self._data["compliance"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class LciMethodWrapper(BaseWrapper):
    """Auto-generated wrapper for LciMethodWrapper."""

    __slots__ = ()

    @property
    def type_of_data_set(self) -> str:
        """Access typeOfDataSet field"""
        return self._data.get("typeOfDataSet")

    @type_of_data_set.setter
    def type_of_data_set(self, value: str) -> None:
        """Set typeOfDataSet."""
        self._data["typeOfDataSet"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ModellingAndValidationWrapper(BaseWrapper):
    """Auto-generated wrapper for ModellingAndValidationWrapper."""

    __slots__ = ()

    @property
    def lci_method(self) -> LciMethodWrapper:
        """Access LCIMethod nested object"""
        self._ensure_field("LCIMethod")
        return LciMethodWrapper(self._entity, self._data["LCIMethod"])

    @property
    def compliance_declarations(self) -> ComplianceDeclarationsWrapper:
        """Access complianceDeclarations nested object"""
        self._ensure_field("complianceDeclarations")
        return ComplianceDeclarationsWrapper(self._entity, self._data["complianceDeclarations"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class TechnologyWrapper(BaseWrapper):
    """Auto-generated wrapper for TechnologyWrapper."""

    __slots__ = ()

    @property
    def technological_applicability(self) -> MultiLangText:
        """Description of the intended / possible applications of the good or service, or waste. E.g. for which type of products the material, represented by this data set, is used. Examples: "This high purity chemical is used for analytical laboratories only." or "This technical quality bulk chemical is used for large scale synthesis in chemical industry.". Or: "This type of biowaste is typically composted or biodigested as the water content is too high for efficient combustion"."""
        return self._get_multi_lang("technologicalApplicability")

    @property
    def reference_to_technical_specification(self) -> Optional[str]:
        """"Source data set(s)" of the product's or waste's technical specification, waste data sheet, safety data sheet, etc."""
        return self._data.get("referenceToTechnicalSpecification")

    @reference_to_technical_specification.setter
    def reference_to_technical_specification(self, value: Optional[str]) -> None:
        """Set referenceToTechnicalSpecification."""
        if value is None:
            self._data.pop("referenceToTechnicalSpecification", None)
        else:
            self._data["referenceToTechnicalSpecification"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class GeographyWrapper(BaseWrapper):
    """Auto-generated wrapper for GeographyWrapper."""

    __slots__ = ()

    @property
    def location_of_supply(self) -> Optional[str]:
        """Access locationOfSupply field"""
        return self._data.get("locationOfSupply")

    @location_of_supply.setter
    def location_of_supply(self, value: Optional[str]) -> None:
        """Set locationOfSupply."""
        if value is None:
            self._data.pop("locationOfSupply", None)
        else:
            self._data["locationOfSupply"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class QuantitativeReferenceWrapper(BaseWrapper):
    """Auto-generated wrapper for QuantitativeReferenceWrapper."""

    __slots__ = ()

    @property
    def reference_to_reference_flow_property(self) -> str:
        """Access referenceToReferenceFlowProperty field"""
        return self._data.get("referenceToReferenceFlowProperty")

    @reference_to_reference_flow_property.setter
    def reference_to_reference_flow_property(self, value: str) -> None:
        """Set referenceToReferenceFlowProperty."""
        self._data["referenceToReferenceFlowProperty"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassificationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationWrapper."""

    __slots__ = ()

    @property
    def class_(self) -> str:
        """Access common:class field"""
        return self._data.get("common:class")

    @class_.setter
    def class_(self, value: str) -> None:
        """Set common:class."""
        self._data["common:class"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ElementaryFlowCategorizationWrapper(BaseWrapper):
    """Auto-generated wrapper for ElementaryFlowCategorizationWrapper."""

    __slots__ = ()

    @property
    def category(self) -> str:
        """Access common:category field"""
        return self._data.get("common:category")

    @category.setter
    def category(self, value: str) -> None:
        """Set common:category."""
        self._data["common:category"] = value

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassificationInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationInformationWrapper."""

    __slots__ = ()

    @property
    def elementary_flow_categorization(self) -> ElementaryFlowCategorizationWrapper:
        """Access common:elementaryFlowCategorization nested object"""
        self._ensure_field("common:elementaryFlowCategorization")
        return ElementaryFlowCategorizationWrapper(self._entity, self._data["common:elementaryFlowCategorization"])

    @property
    def classification(self) -> ClassificationWrapper:
        """Access common:classification nested object"""
        self._ensure_field("common:classification")
        return ClassificationWrapper(self._entity, self._data["common:classification"])


class NameWrapper(BaseWrapper):
    """Auto-generated wrapper for NameWrapper."""

    __slots__ = ()

    @property
    def base_name(self) -> MultiLangText:
        """Access baseName multi-language field"""
        return self._get_multi_lang("baseName")

    @property
    def treatment_standards_routes(self) -> MultiLangText:
        """Access treatmentStandardsRoutes multi-language field"""
        return self._get_multi_lang("treatmentStandardsRoutes")

    @property
    def mix_and_location_types(self) -> MultiLangText:
        """Access mixAndLocationTypes multi-language field"""
        return self._get_multi_lang("mixAndLocationTypes")

    @property
    def flow_properties(self) -> MultiLangText:
        """Access flowProperties multi-language field"""
        return self._get_multi_lang("flowProperties")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataSetInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for DataSetInformationWrapper."""

    __slots__ = ()

    @property
    def uuid(self) -> str:
        """Automatically generated Universally Unique Identifier of this data set. Together with the "Data set version", the UUID uniquely identifies each data set."""
        return self._data.get("common:UUID")

    @uuid.setter
    def uuid(self, value: str) -> None:
        """Set common:UUID."""
        self._data["common:UUID"] = value

    @property
    def name(self) -> NameWrapper:
        """Access name nested object"""
        self._ensure_field("name")
        return NameWrapper(self._entity, self._data["name"])

    @property
    def synonyms(self) -> MultiLangText:
        """Synonyms / alternative names / brands of the good, service, or process. Separated by semicolon."""
        return self._get_multi_lang("common:synonyms")

    @property
    def classification_information(self) -> ClassificationInformationWrapper:
        """Hierachical classification of the Flow property foreseen to be used to structure the Flow property content of the database. (Note: This entry is NOT required for the identification of the Flow property data set. It should nevertheless be avoided to use identical names for Flow properties in the same class."""
        self._ensure_field("classificationInformation")
        return ClassificationInformationWrapper(self._entity, self._data["classificationInformation"])

    @property
    def cas_number(self) -> Optional[str]:
        """Chemical Abstract Systems Number of the substance. [Note: Should only be given for (virtually) pure substances, but NOT also for the main constituent of a material or product etc.]"""
        return self._data.get("CASNumber")

    @cas_number.setter
    def cas_number(self, value: Optional[str]) -> None:
        """Set CASNumber."""
        if value is None:
            self._data.pop("CASNumber", None)
        else:
            self._data["CASNumber"] = value

    @property
    def sum_formula(self) -> Optional[str]:
        """Chemical sum formula of the substance."""
        return self._data.get("sumFormula")

    @sum_formula.setter
    def sum_formula(self, value: Optional[str]) -> None:
        """Set sumFormula."""
        if value is None:
            self._data.pop("sumFormula", None)
        else:
            self._data["sumFormula"] = value

    @property
    def general_comment(self) -> MultiLangText:
        """Free text for general information about the Flow data set. It may contain information about e.g. the use of the substance, good, service or process in a specific technology or industry-context, information sources used, data selection principles etc."""
        return self._get_multi_lang("common:generalComment")

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class FlowInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for FlowInformationWrapper."""

    __slots__ = ()

    @property
    def data_set_information(self) -> DataSetInformationWrapper:
        """Access dataSetInformation nested object"""
        self._ensure_field("dataSetInformation")
        return DataSetInformationWrapper(self._entity, self._data["dataSetInformation"])

    @property
    def quantitative_reference(self) -> QuantitativeReferenceWrapper:
        """Access quantitativeReference nested object"""
        self._ensure_field("quantitativeReference")
        return QuantitativeReferenceWrapper(self._entity, self._data["quantitativeReference"])

    @property
    def geography(self) -> GeographyWrapper:
        """Access geography nested object"""
        self._ensure_field("geography")
        return GeographyWrapper(self._entity, self._data["geography"])

    @property
    def technology(self) -> TechnologyWrapper:
        """Access technology nested object"""
        self._ensure_field("technology")
        return TechnologyWrapper(self._entity, self._data["technology"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class FlowsDataSetWrapper(BaseWrapper):
    """Auto-generated wrapper for FlowsDataSetWrapper."""

    __slots__ = ()

    @property
    def version(self) -> str:
        """Access @version field"""
        return self._data.get("@version")

    @version.setter
    def version(self, value: str) -> None:
        """Set @version."""
        self._data["@version"] = value

    @property
    def locations(self) -> str:
        """Access @locations field"""
        return self._data.get("@locations")

    @locations.setter
    def locations(self, value: str) -> None:
        """Set @locations."""
        self._data["@locations"] = value

    @property
    def schema_location(self) -> str:
        """Access @xsi:schemaLocation field"""
        return self._data.get("@xsi:schemaLocation")

    @schema_location.setter
    def schema_location(self, value: str) -> None:
        """Set @xsi:schemaLocation."""
        self._data["@xsi:schemaLocation"] = value

    @property
    def flow_information(self) -> FlowInformationWrapper:
        """Access flowInformation nested object"""
        self._ensure_field("flowInformation")
        return FlowInformationWrapper(self._entity, self._data["flowInformation"])

    @property
    def modelling_and_validation(self) -> ModellingAndValidationWrapper:
        """Access modellingAndValidation nested object"""
        self._ensure_field("modellingAndValidation")
        return ModellingAndValidationWrapper(self._entity, self._data["modellingAndValidation"])

    @property
    def administrative_information(self) -> AdministrativeInformationWrapper:
        """Access administrativeInformation nested object"""
        self._ensure_field("administrativeInformation")
        return AdministrativeInformationWrapper(self._entity, self._data["administrativeInformation"])

    @property
    def flow_properties(self) -> FlowPropertiesWrapper:
        """Access flowProperties nested object"""
        self._ensure_field("flowProperties")
        return FlowPropertiesWrapper(self._entity, self._data["flowProperties"])

    @property
    def other(self) -> Optional[str]:
        """Access common:other field"""
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value
