"""
Auto-generated typed wrappers for flows entity.

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated from JSON schemas.
To regenerate, run: uv run python scripts/generate_wrappers.py
"""

from typing import Optional

from tidas_sdk.core.typed_access import BaseWrapper, MultiLangText



class FlowPropertiesWrapper(BaseWrapper):
    """Auto-generated wrapper for FlowPropertiesWrapper."""

    __slots__ = ()

    @property
    def flow_property(self) -> str:
        """ Access flowProperty field """
        return self._data.get("flowProperty")

    @flow_property.setter
    def flow_property(self, value: str) -> None:
        """Set flowProperty."""
        self._data["flowProperty"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class PublicationAndOwnershipWrapper(BaseWrapper):
    """Auto-generated wrapper for PublicationAndOwnershipWrapper."""

    __slots__ = ()

    @property
    def data_set_version(self) -> str:
        """ Version number of data set. First two digits refer to major updates, the second two digits to minor revisions and error corrections etc. The third three digits are intended for automatic and internal counting of versions during data set development. Together with the data set's UUID, the "Data set version" uniquely identifies each data set. """
        return self._data.get("common:dataSetVersion")

    @data_set_version.setter
    def data_set_version(self, value: str) -> None:
        """Set common:dataSetVersion."""
        self._data["common:dataSetVersion"] = value

    @property
    def reference_to_preceding_data_set_version(self) -> Optional[str]:
        """ Last preceding data set, which was replaced by this version. Either a URI of that data set (i.e. an internet address) or its UUID plus version number is given (or both). """
        return self._data.get("common:referenceToPrecedingDataSetVersion")

    @reference_to_preceding_data_set_version.setter
    def reference_to_preceding_data_set_version(self, value: Optional[str]) -> None:
        """Set common:referenceToPrecedingDataSetVersion."""
        if value is None:
            self._data.pop("common:referenceToPrecedingDataSetVersion", None)
        else:
            self._data["common:referenceToPrecedingDataSetVersion"] = value

    @property
    def permanent_data_set_uri(self) -> Optional[str]:
        """ URI (i.e. an internet address) of the original of this data set. [Note: This equally globally unique identifier supports users and software tools to identify and retrieve the original version of a data set via the internet or to check for available updates. The URI must not represent an existing WWW address, but it should be unique and point to the data access point, e.g. by combining the data owner's www path with the data set's UUID, e.g. http://www.mycompany.com/lca/processes/50f12420-8855-12db-b606-0900210c9a66.] """
        return self._data.get("common:permanentDataSetURI")

    @permanent_data_set_uri.setter
    def permanent_data_set_uri(self, value: Optional[str]) -> None:
        """Set common:permanentDataSetURI."""
        if value is None:
            self._data.pop("common:permanentDataSetURI", None)
        else:
            self._data["common:permanentDataSetURI"] = value

    @property
    def reference_to_ownership_of_data_set(self) -> str:
        """ "Contact data set" of the person or entity who owns this data set. (Note: this is not necessarily the publisher of the data set.) """
        return self._data.get("common:referenceToOwnershipOfDataSet")

    @reference_to_ownership_of_data_set.setter
    def reference_to_ownership_of_data_set(self, value: str) -> None:
        """Set common:referenceToOwnershipOfDataSet."""
        self._data["common:referenceToOwnershipOfDataSet"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataEntryByWrapper(BaseWrapper):
    """Auto-generated wrapper for DataEntryByWrapper."""

    __slots__ = ()

    @property
    def time_stamp(self) -> str:
        """ Date and time stamp of data set generation, typically an automated entry ("last saved"). """
        return self._data.get("common:timeStamp")

    @time_stamp.setter
    def time_stamp(self, value: str) -> None:
        """Set common:timeStamp."""
        self._data["common:timeStamp"] = value

    @property
    def reference_to_data_set_format(self) -> str:
        """ "Source data set" of the used version of the ILCD format. If additional data format fields have been integrated into the data set file, using the "namespace" option, the used format namespace(s) are to be given. This is the case if the data sets carries additional information as specified by other, particular LCA formats, e.g. of other database networks or LCA softwares. """
        return self._data.get("common:referenceToDataSetFormat")

    @reference_to_data_set_format.setter
    def reference_to_data_set_format(self, value: str) -> None:
        """Set common:referenceToDataSetFormat."""
        self._data["common:referenceToDataSetFormat"] = value

    @property
    def reference_to_person_or_entity_entering_the_data(self) -> Optional[str]:
        """ "Contact data set" of the responsible person or entity that has documented this data set, i.e. entered the data and the descriptive information. """
        return self._data.get("common:referenceToPersonOrEntityEnteringTheData")

    @reference_to_person_or_entity_entering_the_data.setter
    def reference_to_person_or_entity_entering_the_data(self, value: Optional[str]) -> None:
        """Set common:referenceToPersonOrEntityEnteringTheData."""
        if value is None:
            self._data.pop("common:referenceToPersonOrEntityEnteringTheData", None)
        else:
            self._data["common:referenceToPersonOrEntityEnteringTheData"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class AdministrativeInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for AdministrativeInformationWrapper."""

    __slots__ = ()

    @property
    def data_entry_by(self) -> DataEntryByWrapper:
        """ Access dataEntryBy nested object """
        self._ensure_field("dataEntryBy")
        return DataEntryByWrapper(self._entity, self._data["dataEntryBy"])

    @property
    def publication_and_ownership(self) -> PublicationAndOwnershipWrapper:
        """ Access publicationAndOwnership nested object """
        self._ensure_field("publicationAndOwnership")
        return PublicationAndOwnershipWrapper(self._entity, self._data["publicationAndOwnership"])

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ComplianceDeclarationsWrapper(BaseWrapper):
    """Auto-generated wrapper for ComplianceDeclarationsWrapper."""

    __slots__ = ()

    @property
    def compliance(self) -> str:
        """ One compliance declaration. Multiple declarations may be provided. """
        return self._data.get("compliance")

    @compliance.setter
    def compliance(self, value: str) -> None:
        """Set compliance."""
        self._data["compliance"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class LciMethodWrapper(BaseWrapper):
    """Auto-generated wrapper for LciMethodWrapper."""

    __slots__ = ()

    @property
    def type_of_data_set(self) -> str:
        """ Access typeOfDataSet field """
        return self._data.get("typeOfDataSet")

    @type_of_data_set.setter
    def type_of_data_set(self, value: str) -> None:
        """Set typeOfDataSet."""
        self._data["typeOfDataSet"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ModellingAndValidationWrapper(BaseWrapper):
    """Auto-generated wrapper for ModellingAndValidationWrapper."""

    __slots__ = ()

    @property
    def lci_method(self) -> LciMethodWrapper:
        """ Access LCIMethod nested object """
        self._ensure_field("LCIMethod")
        return LciMethodWrapper(self._entity, self._data["LCIMethod"])

    @property
    def compliance_declarations(self) -> ComplianceDeclarationsWrapper:
        """ Access complianceDeclarations nested object """
        self._ensure_field("complianceDeclarations")
        return ComplianceDeclarationsWrapper(self._entity, self._data["complianceDeclarations"])

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class TechnologyWrapper(BaseWrapper):
    """Auto-generated wrapper for TechnologyWrapper."""

    __slots__ = ()

    @property
    def technological_applicability(self) -> MultiLangText:
        """ Description of the intended / possible applications of the good or service, or waste. E.g. for which type of products the material, represented by this data set, is used. Examples: "This high purity chemical is used for analytical laboratories only." or "This technical quality bulk chemical is used for large scale synthesis in chemical industry.". Or: "This type of biowaste is typically composted or biodigested as the water content is too high for efficient combustion". """
        return self._get_multi_lang("technologicalApplicability")

    @property
    def reference_to_technical_specification(self) -> Optional[str]:
        """ "Source data set(s)" of the product's or waste's technical specification, waste data sheet, safety data sheet, etc. """
        return self._data.get("referenceToTechnicalSpecification")

    @reference_to_technical_specification.setter
    def reference_to_technical_specification(self, value: Optional[str]) -> None:
        """Set referenceToTechnicalSpecification."""
        if value is None:
            self._data.pop("referenceToTechnicalSpecification", None)
        else:
            self._data["referenceToTechnicalSpecification"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class GeographyWrapper(BaseWrapper):
    """Auto-generated wrapper for GeographyWrapper."""

    __slots__ = ()

    @property
    def location_of_supply(self) -> Optional[str]:
        """ Access locationOfSupply field """
        return self._data.get("locationOfSupply")

    @location_of_supply.setter
    def location_of_supply(self, value: Optional[str]) -> None:
        """Set locationOfSupply."""
        if value is None:
            self._data.pop("locationOfSupply", None)
        else:
            self._data["locationOfSupply"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class QuantitativeReferenceWrapper(BaseWrapper):
    """Auto-generated wrapper for QuantitativeReferenceWrapper."""

    __slots__ = ()

    @property
    def reference_to_reference_flow_property(self) -> str:
        """ Access referenceToReferenceFlowProperty field """
        return self._data.get("referenceToReferenceFlowProperty")

    @reference_to_reference_flow_property.setter
    def reference_to_reference_flow_property(self, value: str) -> None:
        """Set referenceToReferenceFlowProperty."""
        self._data["referenceToReferenceFlowProperty"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassificationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationWrapper."""

    __slots__ = ()

    @property
    def class_(self) -> str:
        """ Access common:class field """
        return self._data.get("common:class")

    @class_.setter
    def class_(self, value: str) -> None:
        """Set common:class."""
        self._data["common:class"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ElementaryFlowCategorizationWrapper(BaseWrapper):
    """Auto-generated wrapper for ElementaryFlowCategorizationWrapper."""

    __slots__ = ()

    @property
    def category(self) -> str:
        """ Access common:category field """
        return self._data.get("common:category")

    @category.setter
    def category(self, value: str) -> None:
        """Set common:category."""
        self._data["common:category"] = value

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class ClassificationInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for ClassificationInformationWrapper."""

    __slots__ = ()

    @property
    def elementary_flow_categorization(self) -> ElementaryFlowCategorizationWrapper:
        """ Access common:elementaryFlowCategorization nested object """
        self._ensure_field("common:elementaryFlowCategorization")
        return ElementaryFlowCategorizationWrapper(self._entity, self._data["common:elementaryFlowCategorization"])

    @property
    def classification(self) -> ClassificationWrapper:
        """ Access common:classification nested object """
        self._ensure_field("common:classification")
        return ClassificationWrapper(self._entity, self._data["common:classification"])


class NameWrapper(BaseWrapper):
    """Auto-generated wrapper for NameWrapper."""

    __slots__ = ()

    @property
    def base_name(self) -> MultiLangText:
        """ Access baseName multi-language field """
        return self._get_multi_lang("baseName")

    @property
    def treatment_standards_routes(self) -> MultiLangText:
        """ Access treatmentStandardsRoutes multi-language field """
        return self._get_multi_lang("treatmentStandardsRoutes")

    @property
    def mix_and_location_types(self) -> MultiLangText:
        """ Access mixAndLocationTypes multi-language field """
        return self._get_multi_lang("mixAndLocationTypes")

    @property
    def flow_properties(self) -> MultiLangText:
        """ Access flowProperties multi-language field """
        return self._get_multi_lang("flowProperties")

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class DataSetInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for DataSetInformationWrapper."""

    __slots__ = ()

    @property
    def uuid(self) -> str:
        """ Automatically generated Universally Unique Identifier of this data set. Together with the "Data set version", the UUID uniquely identifies each data set. """
        return self._data.get("common:UUID")

    @uuid.setter
    def uuid(self, value: str) -> None:
        """Set common:UUID."""
        self._data["common:UUID"] = value

    @property
    def name(self) -> NameWrapper:
        """ Access name nested object """
        self._ensure_field("name")
        return NameWrapper(self._entity, self._data["name"])

    @property
    def synonyms(self) -> MultiLangText:
        """ Synonyms / alternative names / brands of the good, service, or process. Separated by semicolon. """
        return self._get_multi_lang("common:synonyms")

    @property
    def classification_information(self) -> ClassificationInformationWrapper:
        """ Hierachical classification of the Flow property foreseen to be used to structure the Flow property content of the database. (Note: This entry is NOT required for the identification of the Flow property data set. It should nevertheless be avoided to use identical names for Flow properties in the same class. """
        self._ensure_field("classificationInformation")
        return ClassificationInformationWrapper(self._entity, self._data["classificationInformation"])

    @property
    def cas_number(self) -> Optional[str]:
        """ Chemical Abstract Systems Number of the substance. [Note: Should only be given for (virtually) pure substances, but NOT also for the main constituent of a material or product etc.] """
        return self._data.get("CASNumber")

    @cas_number.setter
    def cas_number(self, value: Optional[str]) -> None:
        """Set CASNumber."""
        if value is None:
            self._data.pop("CASNumber", None)
        else:
            self._data["CASNumber"] = value

    @property
    def sum_formula(self) -> Optional[str]:
        """ Chemical sum formula of the substance. """
        return self._data.get("sumFormula")

    @sum_formula.setter
    def sum_formula(self, value: Optional[str]) -> None:
        """Set sumFormula."""
        if value is None:
            self._data.pop("sumFormula", None)
        else:
            self._data["sumFormula"] = value

    @property
    def general_comment(self) -> MultiLangText:
        """ Free text for general information about the Flow data set. It may contain information about e.g. the use of the substance, good, service or process in a specific technology or industry-context, information sources used, data selection principles etc. """
        return self._get_multi_lang("common:generalComment")

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class FlowInformationWrapper(BaseWrapper):
    """Auto-generated wrapper for FlowInformationWrapper."""

    __slots__ = ()

    @property
    def data_set_information(self) -> DataSetInformationWrapper:
        """ Access dataSetInformation nested object """
        self._ensure_field("dataSetInformation")
        return DataSetInformationWrapper(self._entity, self._data["dataSetInformation"])

    @property
    def quantitative_reference(self) -> QuantitativeReferenceWrapper:
        """ Access quantitativeReference nested object """
        self._ensure_field("quantitativeReference")
        return QuantitativeReferenceWrapper(self._entity, self._data["quantitativeReference"])

    @property
    def geography(self) -> GeographyWrapper:
        """ Access geography nested object """
        self._ensure_field("geography")
        return GeographyWrapper(self._entity, self._data["geography"])

    @property
    def technology(self) -> TechnologyWrapper:
        """ Access technology nested object """
        self._ensure_field("technology")
        return TechnologyWrapper(self._entity, self._data["technology"])

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value


class FlowsDataSetWrapper(BaseWrapper):
    """Auto-generated wrapper for FlowsDataSetWrapper."""

    __slots__ = ()

    @property
    def version(self) -> str:
        """ Access @version field """
        return self._data.get("@version")

    @version.setter
    def version(self, value: str) -> None:
        """Set @version."""
        self._data["@version"] = value

    @property
    def locations(self) -> str:
        """ Access @locations field """
        return self._data.get("@locations")

    @locations.setter
    def locations(self, value: str) -> None:
        """Set @locations."""
        self._data["@locations"] = value

    @property
    def schema_location(self) -> str:
        """ Access @xsi:schemaLocation field """
        return self._data.get("@xsi:schemaLocation")

    @schema_location.setter
    def schema_location(self, value: str) -> None:
        """Set @xsi:schemaLocation."""
        self._data["@xsi:schemaLocation"] = value

    @property
    def flow_information(self) -> FlowInformationWrapper:
        """ Access flowInformation nested object """
        self._ensure_field("flowInformation")
        return FlowInformationWrapper(self._entity, self._data["flowInformation"])

    @property
    def modelling_and_validation(self) -> ModellingAndValidationWrapper:
        """ Access modellingAndValidation nested object """
        self._ensure_field("modellingAndValidation")
        return ModellingAndValidationWrapper(self._entity, self._data["modellingAndValidation"])

    @property
    def administrative_information(self) -> AdministrativeInformationWrapper:
        """ Access administrativeInformation nested object """
        self._ensure_field("administrativeInformation")
        return AdministrativeInformationWrapper(self._entity, self._data["administrativeInformation"])

    @property
    def flow_properties(self) -> FlowPropertiesWrapper:
        """ Access flowProperties nested object """
        self._ensure_field("flowProperties")
        return FlowPropertiesWrapper(self._entity, self._data["flowProperties"])

    @property
    def other(self) -> Optional[str]:
        """ Access common:other field """
        return self._data.get("common:other")

    @other.setter
    def other(self, value: Optional[str]) -> None:
        """Set common:other."""
        if value is None:
            self._data.pop("common:other", None)
        else:
            self._data["common:other"] = value
